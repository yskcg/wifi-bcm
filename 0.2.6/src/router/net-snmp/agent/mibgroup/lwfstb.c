/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/time.h>

#include <bcmnvram.h>
#include <shutils.h>
#include <wlutils.h>

#include "lwfstb.h"

#define INTEGER_ENABLE 1
#define INTEGER_DISABLE 2

#define SSID_MAX_LEN 15

#define SECNONE  0x0
#define  WPAPSK (0x01 << 0)
#define WPA2PSK (0x01 << 1)

#define MAXPSKLEN 15

#define WIFIabgnmode 1
#define WIFIacmode 2

#define WIFI_ROUTER 1
#define WIFI_BRIDGE 2
#define WIFI_AP     3
#define WIFI_WDS    4

#define OPENED_WIFI 1
#define CLOSED_WIFI 2

#define CHANNEL_20M_24G 1
#define CHANNEL_40M_24G 2
#define CHANNEL_NOTSP_BDW 9

#define UPPER_CHNANNEL_40M 7
#define UPPER_CHNANNEL_20M 13

#define MAXUSRNMLEN 15

#define MAXSSIDHDRLEN 8

#define MAXSSIDLEN 15

#define WANDHCPOK 1
#define WANDHCPNOK 2

#define SETTINGSAPPLYNON 0
#define SETTINGSAPPLYINPROGRESS 1

#define APPLYSETTINGS 1

#define ENCRYCLEAR 0x00
#define ENCRYAES (0x01 << 0)
#define ENCRYTKIPAES (0x01 << 1)

#define MACADDRSTRLEN 17

#define MAX_STA_COUNT 256

#define REBUILDTABLEINTERVAL 5

static int factoryrestorestatus;
static bool superadminmodeenabled;
static int applysettingstatus;

static struct timeval builddhcpclienttabletime;
static struct timeval buildwifistationtabletime;

struct lease_t {
	unsigned char chaddr[16];
	u_int32_t yiaddr;
	u_int32_t expires;
	char hostname[64];
};

#define sys_restart() kill(1, SIGHUP)

inline void sys_reboot(void)
{
	eval("wl", "reboot");
	kill(1, SIGTERM);
}

int reversesnmpbits(unsigned char bitmask, unsigned char *rbits)
{
    unsigned int i;
    unsigned char tmpbit;

    *rbits = 0x0;
    for(i = 0; i < 8; i++)
    {
        tmpbit = (bitmask >> i) & 0x01;
        *rbits |=  (tmpbit << (7 -i));
    }
}

/** Initializes the lwfstb module */
void
init_lwfstb(void)
{
    const oid lwfwifi0enable_oid[] = { 1,3,6,1,4,1,33898,1,1,1,2 };
    const oid lwfwifi0ssid_oid[] = { 1,3,6,1,4,1,33898,1,1,1,3 };
    const oid lwfwifi0keymgmt_oid[] = { 1,3,6,1,4,1,33898,1,1,1,4 };
    const oid lwfwifi0encryptionm_oid[] = { 1,3,6,1,4,1,33898,1,1,1,5 };
    const oid lwfwifi0password_oid[] = { 1,3,6,1,4,1,33898,1,1,1,6 };
    const oid lwfwifi0phymode_oid[] = { 1,3,6,1,4,1,33898,1,1,1,8 };
    const oid lwfwifi0networkmode_oid[] = { 1,3,6,1,4,1,33898,1,1,1,9 };
    const oid lwfwifi0ssidbroadcast_oid[] = { 1,3,6,1,4,1,33898,1,1,1,10 };
    const oid lwfwifi0channel_oid[] = { 1,3,6,1,4,1,33898,1,1,1,11 };
    const oid lwfwifi0bandwidth_oid[] = { 1,3,6,1,4,1,33898,1,1,1,12 };
    const oid wfwifi0txpower_oid[] = { 1,3,6,1,4,1,33898,1,1,1,14 };
    const oid lwfusername_oid[] = { 1,3,6,1,4,1,33898,1,1,1,15 };
    const oid lwfpassword_oid[] = { 1,3,6,1,4,1,33898,1,1,1,16 };
    const oid lwffactoryrestore_oid[] = { 1,3,6,1,4,1,33898,1,1,1,17 };
    const oid lwfreboot_oid[] = { 1,3,6,1,4,1,33898,1,1,1,18 };
    const oid lwfsupersettingsenable_oid[] = { 1,3,6,1,4,1,33898,1,1,1,26 };
    const oid lwfssidmodifyenable_oid[] = { 1,3,6,1,4,1,33898,1,1,1,27 };
    const oid lwfwifi0ssidheader_oid[] = { 1,3,6,1,4,1,33898,1,1,1,28 };
    const oid lwfwifi1ssid_oid[] = { 1,3,6,1,4,1,33898,1,1,1,29 };
    const oid lwfwifi0mac_oid[] = { 1,3,6,1,4,1,33898,1,1,1,31 };
    const oid lwfwanlink_oid[] = { 1,3,6,1,4,1,33898,1,1,1,33 };
    const oid lwfwanip_oid[] = { 1,3,6,1,4,1,33898,1,1,1,34 };
    const oid lwfwanmask_oid[] = { 1,3,6,1,4,1,33898,1,1,1,35 };
    const oid lwfwandns1_oid[] = { 1,3,6,1,4,1,33898,1,1,1,36 };
    const oid lwfwandns2_oid[] = { 1,3,6,1,4,1,33898,1,1,1,37 };
    const oid lwflanmac_oid[] = { 1,3,6,1,4,1,33898,1,1,1,38 };
    const oid lwflanip_oid[] = { 1,3,6,1,4,1,33898,1,1,1,39 };
    const oid lwflanmask_oid[] = { 1,3,6,1,4,1,33898,1,1,1,40 };
#if 0
    const oid lwfwifi0wpsenable_oid[] = { 1,3,6,1,4,1,33898,1,1,1,42 };
    const oid lwfwifi0wpspin_oid[] = { 1,3,6,1,4,1,33898,1,1,1,43 };
    const oid lwfwifi0wpsstart_oid[] = { 1,3,6,1,4,1,33898,1,1,1,44 };
    const oid lwfwifi0wpsstatus_oid[] = { 1,3,6,1,4,1,33898,1,1,1,45 };
    const oid lwfwifi0wdsremotemac_oid[] = { 1,3,6,1,4,1,33898,1,1,1,47 };
#endif
    const oid lwfapplysettings_oid[] = { 1,3,6,1,4,1,33898,1,1,1,50 };

  DEBUGMSGTL(("lwfstb", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0enable", handle_lwfwifi0enable,
                               lwfwifi0enable_oid, OID_LENGTH(lwfwifi0enable_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0ssid", handle_lwfwifi0ssid,
                               lwfwifi0ssid_oid, OID_LENGTH(lwfwifi0ssid_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0keymgmt", handle_lwfwifi0keymgmt,
                               lwfwifi0keymgmt_oid, OID_LENGTH(lwfwifi0keymgmt_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0encryptionm", handle_lwfwifi0encryptionm,
                               lwfwifi0encryptionm_oid, OID_LENGTH(lwfwifi0encryptionm_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0password", handle_lwfwifi0password,
                               lwfwifi0password_oid, OID_LENGTH(lwfwifi0password_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0phymode", handle_lwfwifi0phymode,
                               lwfwifi0phymode_oid, OID_LENGTH(lwfwifi0phymode_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0networkmode", handle_lwfwifi0networkmode,
                               lwfwifi0networkmode_oid, OID_LENGTH(lwfwifi0networkmode_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0ssidbroadcast", handle_lwfwifi0ssidbroadcast,
                               lwfwifi0ssidbroadcast_oid, OID_LENGTH(lwfwifi0ssidbroadcast_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0channel", handle_lwfwifi0channel,
                               lwfwifi0channel_oid, OID_LENGTH(lwfwifi0channel_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0bandwidth", handle_lwfwifi0bandwidth,
                               lwfwifi0bandwidth_oid, OID_LENGTH(lwfwifi0bandwidth_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("wfwifi0txpower", handle_wfwifi0txpower,
                               wfwifi0txpower_oid, OID_LENGTH(wfwifi0txpower_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfusername", handle_lwfusername,
                               lwfusername_oid, OID_LENGTH(lwfusername_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfpassword", handle_lwfpassword,
                               lwfpassword_oid, OID_LENGTH(lwfpassword_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwffactoryrestore", handle_lwffactoryrestore,
                               lwffactoryrestore_oid, OID_LENGTH(lwffactoryrestore_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfreboot", handle_lwfreboot,
                               lwfreboot_oid, OID_LENGTH(lwfreboot_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfsupersettingsenable", handle_lwfsupersettingsenable,
                               lwfsupersettingsenable_oid, OID_LENGTH(lwfsupersettingsenable_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfssidmodifyenable", handle_lwfssidmodifyenable,
                               lwfssidmodifyenable_oid, OID_LENGTH(lwfssidmodifyenable_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0ssidheader", handle_lwfwifi0ssidheader,
                               lwfwifi0ssidheader_oid, OID_LENGTH(lwfwifi0ssidheader_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi1ssid", handle_lwfwifi1ssid,
                               lwfwifi1ssid_oid, OID_LENGTH(lwfwifi1ssid_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0mac", handle_lwfwifi0mac,
                               lwfwifi0mac_oid, OID_LENGTH(lwfwifi0mac_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwanlink", handle_lwfwanlink,
                               lwfwanlink_oid, OID_LENGTH(lwfwanlink_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwanip", handle_lwfwanip,
                               lwfwanip_oid, OID_LENGTH(lwfwanip_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwanmask", handle_lwfwanmask,
                               lwfwanmask_oid, OID_LENGTH(lwfwanmask_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwandns1", handle_lwfwandns1,
                               lwfwandns1_oid, OID_LENGTH(lwfwandns1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwandns2", handle_lwfwandns2,
                               lwfwandns2_oid, OID_LENGTH(lwfwandns2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwflanmac", handle_lwflanmac,
                               lwflanmac_oid, OID_LENGTH(lwflanmac_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwflanip", handle_lwflanip,
                               lwflanip_oid, OID_LENGTH(lwflanip_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwflanmask", handle_lwflanmask,
                               lwflanmask_oid, OID_LENGTH(lwflanmask_oid),
                               HANDLER_CAN_RONLY
        ));
#if 0
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0wpsenable", handle_lwfwifi0wpsenable,
                               lwfwifi0wpsenable_oid, OID_LENGTH(lwfwifi0wpsenable_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0wpspin", handle_lwfwifi0wpspin,
                               lwfwifi0wpspin_oid, OID_LENGTH(lwfwifi0wpspin_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0wpsstart", handle_lwfwifi0wpsstart,
                               lwfwifi0wpsstart_oid, OID_LENGTH(lwfwifi0wpsstart_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0wpsstatus", handle_lwfwifi0wpsstatus,
                               lwfwifi0wpsstatus_oid, OID_LENGTH(lwfwifi0wpsstatus_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfwifi0wdsremotemac", handle_lwfwifi0wdsremotemac,
                               lwfwifi0wdsremotemac_oid, OID_LENGTH(lwfwifi0wdsremotemac_oid),
                               HANDLER_CAN_RWRITE
        ));
#endif
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lwfapplysettings", handle_lwfapplysettings,
                               lwfapplysettings_oid, OID_LENGTH(lwfapplysettings_oid),
                               HANDLER_CAN_RWRITE
        ));

    /* here we initialize all the tables we're planning on supporting */
    initialize_table_dhcpclientTable();
    initialize_table_wifistationTable();
}

int
handle_lwfwifi0enable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    int radio_on;
    char tmpbuf[8];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            radio_on = INTEGER_DISABLE;
            if(nvram_match("wl_radio", "1") && nvram_match("wl0_radio", "1"))
                radio_on = INTEGER_ENABLE;

            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 
                    radio_on);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            radio_on = *requests->requestvb->val.integer;

            if(radio_on != INTEGER_ENABLE && radio_on != INTEGER_DISABLE)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }

            bzero(tmpbuf,sizeof(tmpbuf));
            if(radio_on == INTEGER_ENABLE)
                snprintf(tmpbuf, sizeof(tmpbuf), "%d",  1);
            else if(radio_on == INTEGER_DISABLE)
                snprintf(tmpbuf, sizeof(tmpbuf), "%d",  0);

            nvram_set("wl_radio", tmpbuf);
            nvram_set("wl0_radio", tmpbuf);

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0enable\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0ssid(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *ssid;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            ssid = nvram_safe_get("wl0_ssid");
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     ssid,
                                     strlen(ssid));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            return SNMP_ERR_RESOURCEUNAVAILABLE;//not allowed to set ssid
            if(requests->requestvb->val_len > SSID_MAX_LEN)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            else
            {
                nvram_set("wl0_ssid", requests->requestvb->val.string);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0ssid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0keymgmt(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *wl_akms, *akmnext;
    unsigned char security = SECNONE;
    unsigned char snmpbits;
    char tmpbuf[16];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            wl_akms = nvram_safe_get("wl0_akm");
            foreach(tmpbuf, wl_akms, akmnext){
                if(strcmp(tmpbuf, "psk") == 0){
                    security = WPAPSK;
                }
                else if(strcmp(tmpbuf, "psk2") == 0){
                    security = WPA2PSK;
                }
            }

            reversesnmpbits(security, &snmpbits);

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    &snmpbits, 1);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            snmpbits = *requests->requestvb->val.string;

            reversesnmpbits(snmpbits, &security);

            if (security & 0xfc) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else
            {
                bzero(tmpbuf, sizeof(tmpbuf));

                if(security & WPAPSK)
                {
                    snprintf(tmpbuf, sizeof(tmpbuf), "%s", "psk ");
                }
                else if(security & WPA2PSK)
                {
                    snprintf(tmpbuf, sizeof(tmpbuf), "%s", "psk2 ");
                }

                nvram_set("wl_akm", tmpbuf);
                nvram_set("wl0_akm", tmpbuf);

                if(nvram_invmatch("wl0_crypto", "tkip") &&
                    nvram_invmatch("wl0_crypto", "aes") &&
                    nvram_invmatch("wl0_crypto", "tkip+aes"))
                {
                    nvram_set("wl_crypto", "tkip+aes");
                    nvram_set("wl0_crypto", "tkip+aes");
                }

                if(nvram_match("wl_wpa_psk", ""))
                {
                    nvram_set("wl_wpa_psk", "12345678");
                    nvram_set("wl0_wpa_psk", "12345678");
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0secmethod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0encryptionm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    bool pskakm = FALSE;
    char *wl_akms, *akmnext;
    unsigned char encryptionmethod = ENCRYCLEAR;
    unsigned char snmpbits;
    char tmpbuf[16];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(nvram_match("wl_crypto", "aes"))
                encryptionmethod = ENCRYAES;
            else if(nvram_match("wl_crypto", "tkip+aes"))
                encryptionmethod = ENCRYTKIPAES;

            reversesnmpbits(encryptionmethod, &snmpbits);

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    &snmpbits, 1);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            snmpbits = *requests->requestvb->val.string;

            reversesnmpbits(snmpbits, &encryptionmethod);

            if (encryptionmethod & 0xfc ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else
            {
                bzero(tmpbuf, sizeof(tmpbuf));

                if(encryptionmethod & ENCRYTKIPAES)
                    snprintf(tmpbuf, sizeof(tmpbuf), "%s", "tkip+aes");
                else if(encryptionmethod & ENCRYAES)
                    snprintf(tmpbuf, sizeof(tmpbuf), "%s", "aes");

                nvram_set("wl_crypto", tmpbuf);
                nvram_set("wl0_crypto", tmpbuf);

                wl_akms = nvram_safe_get("wl0_akm");
                foreach(tmpbuf, wl_akms, akmnext)
                {
                    if((strcmp(tmpbuf, "psk") == 0) ||
                            (strcmp(tmpbuf, "psk2") == 0))
                        pskakm = TRUE;
                }

                if(!pskakm)
                {
                    nvram_set("wl_akm", "psk2");
                    nvram_set("wl0_akm", "psk2");
                }

                if(nvram_match("wl_wpa_psk", ""))
                {
                    nvram_set("wl_wpa_psk", "12345678");
                    nvram_set("wl0_wpa_psk", "12345678");
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0secmethod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0password(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret, psklen;
    char *pwd;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            pwd = nvram_safe_get("wl0_wpa_psk");
            psklen = strlen(pwd);
            if(psklen > MAXPSKLEN)
                psklen = MAXPSKLEN;

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     pwd, psklen);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:

            if (strlen(requests->requestvb->val.string) > MAXPSKLEN) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            else{
                nvram_set("wl_wpa_psk", requests->requestvb->val.string);
                nvram_set("wl0_wpa_psk", requests->requestvb->val.string);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0password\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0phymode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     WIFIabgnmode);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOTWRITABLE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0phymode\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0networkmode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     WIFI_ROUTER);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (0/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOTWRITABLE);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0networkmode\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0ssidbroadcast(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    int ssid_bcast;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(nvram_match("wl0_closed", "1"))
                ssid_bcast = CLOSED_WIFI;
            else
                ssid_bcast = OPENED_WIFI;

            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     ssid_bcast);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            ssid_bcast = *requests->requestvb->val.integer;

            if (ssid_bcast != CLOSED_WIFI && ssid_bcast != OPENED_WIFI) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else{
                if(ssid_bcast == CLOSED_WIFI){
                    nvram_set("wl_closed", "1");
                    nvram_set("wl0_closed", "1");
                }
                else{
                    nvram_set("wl_closed", "0");
                    nvram_set("wl0_closed", "0");
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0ssidbroadcast\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0channel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *pchan;
    int fchan, channelupper = UPPER_CHNANNEL_20M;
    char tmpbuf[8];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            pchan = nvram_safe_get("wl0_channel");
            fchan = atoi(pchan);

            if(fchan <= 13 && fchan >= 1)
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     fchan);
            else
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     0);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            fchan = *requests->requestvb->val.integer;

            if(nvram_match("wl0_nbw_cap", "1"))
                channelupper = UPPER_CHNANNEL_40M;

            if (fchan < 1 || fchan > channelupper) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else{
                bzero(tmpbuf, sizeof(tmpbuf));
                snprintf(tmpbuf, sizeof(tmpbuf), "%d", fchan);
                nvram_set("wl_channel",tmpbuf);
                nvram_set("wl0_channel",tmpbuf);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0channel\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0bandwidth(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *pnval;
    int bandwidth;
    char tmpbuf[8];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(nvram_match("wl0_nbw_cap", "0"))
                bandwidth = CHANNEL_20M_24G;
            else if(nvram_match("wl0_nbw_cap", "1"))
                bandwidth = CHANNEL_40M_24G;
            else
                bandwidth = CHANNEL_NOTSP_BDW;

            if(bandwidth != CHANNEL_NOTSP_BDW)
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     bandwidth);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            bandwidth = *requests->requestvb->val.integer;

            if (bandwidth != CHANNEL_20M_24G && bandwidth != CHANNEL_40M_24G) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else{
                bzero(tmpbuf, sizeof(tmpbuf));

                if(bandwidth == CHANNEL_20M_24G)
                    snprintf(tmpbuf, sizeof(tmpbuf), "%d", 0);
                else if(bandwidth == CHANNEL_40M_24G)
                    snprintf(tmpbuf, sizeof(tmpbuf), "%d", 1);

                nvram_set("wl_nbw_cap", tmpbuf);
                nvram_set("wl0_nbw_cap", tmpbuf);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0bandwidth\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

//todo: add new parameter wl0_txpower to nvram
int
handle_wfwifi0txpower(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *pval;
    int txpower;
    char tmpbuf[8];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("wl0_txpower");
            if(!strcmp(pval, ""))
                txpower = atoi(pval);

            if(txpower > 0 && txpower < 100)
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     txpower);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            txpower = *requests->requestvb->val.integer;
            if (txpower < 0 || txpower > 100) {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_BADVALUE);
            }
            else{
                bzero(tmpbuf, sizeof(tmpbuf));
                snprintf(tmpbuf, sizeof(tmpbuf), "%d", txpower);
                nvram_set("wl0_txpower", tmpbuf);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_wfwifi0txpower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfusername(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret, length;
    char *pval;
    char tmpbuf[16];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("http_username");
            length = strlen(pval);
            if(length <= MAXUSRNMLEN)
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                        pval, length);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if(strlen(requests->requestvb->val.string) < MAXUSRNMLEN)
                nvram_set("http_username", requests->requestvb->val.string);
            else{
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfusername\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfpassword(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret, length;
    char *pval;
    char tmpbuf[16];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("http_passwd");
            length = strlen(pval);
            if(length <= MAXUSRNMLEN)
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                        pval, length);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if(strlen(requests->requestvb->val.string) < MAXUSRNMLEN)
                nvram_set("http_passwd", requests->requestvb->val.string);
            else{
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfpassword\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwffactoryrestore(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     factoryrestorestatus);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if (*requests->requestvb->val.integer == 1) {
                factoryrestorestatus = 1;
                eval("erase", "nvram");
                factoryrestorestatus = 0;
                sys_reboot();
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwffactoryrestore\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfreboot(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     0);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if (*requests->requestvb->val.integer == 1) {
                sys_reboot();
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfreboot\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfsupersettingsenable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret, superadminmode;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(superadminmodeenabled)
                superadminmode= INTEGER_ENABLE;
            else 
                superadminmode = INTEGER_DISABLE;

            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     superadminmode);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if (*requests->requestvb->val.integer == INTEGER_ENABLE)
                superadminmodeenabled = TRUE;
            else if(*requests->requestvb->val.integer == INTEGER_DISABLE)
                superadminmodeenabled = FALSE;
            else
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfsupersettingsenable\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

//TODO: add a new nvram wl0_ssidheader_changable
int
handle_lwfssidmodifyenable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *pval;
    int ssid_header_changable;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            if(!superadminmodeenabled)
                break;

            if(nvram_match("wl0_ssidheader_changable", "1"))
                ssid_header_changable = INTEGER_ENABLE;
            else
                ssid_header_changable = INTEGER_DISABLE;

            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     ssid_header_changable);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if(!superadminmodeenabled){
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                break;
            }

            if(*requests->requestvb->val.integer == INTEGER_ENABLE)
                nvram_set("wl0_ssidheader_changable", "1");
            else if(*requests->requestvb->val.integer == INTEGER_DISABLE)
                nvram_set("wl0_ssidheader_changable", "0");
            else{
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfssidmodifyenable\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

//TODO: add a new nvram wl0_ssidheader to save ssid header of wl0
int
handle_lwfwifi0ssidheader(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    char *pval;
    int length;
    char ssid[16];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(!superadminmodeenabled)
                break;

            pval = nvram_safe_get("wl0_ssidheader");
            length = strlen(pval);
            if( length < MAXSSIDHDRLEN )
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                        pval, length);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if(!superadminmodeenabled || \
                    nvram_invmatch("wl0_ssidheader_changable", "1")){
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                break;
            }

            if(strlen(requests->requestvb->val.string) > MAXSSIDHDRLEN){
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            else{
                 nvram_set("wl0_ssidheader", requests->requestvb->val.string);

                 pval = nvram_get("sb/1/macaddr");
                 if(!pval){
                     snmp_log(LOG_ERR, "failed to get wifi mac address\n");
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                 }
                 else{
                     memset(ssid, 0, sizeof(ssid));
                     snprintf(ssid, sizeof(ssid), "%s_%s",\
                             requests->requestvb->val.string, &pval[9]);

                     nvram_set("wl_ssid", ssid);
                     nvram_set("wl0_ssid", ssid);
                 }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0ssidheader\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi1ssid(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret, length;
    char *pval;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            if(!superadminmodeenabled)
                break;

            pval = nvram_safe_get("wl0.1_ssid");
            length = strlen(pval);
            if(length < MAXSSIDLEN)
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                        pval, length);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            if(!superadminmodeenabled){
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                break;
            }

            length = strlen(requests->requestvb->val.string);
            if (length > MAXSSIDLEN) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            else{
                nvram_set("wl0.1_ssid", requests->requestvb->val.string);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi1ssid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0mac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        char *mac;

        case MODE_GET:
            mac = nvram_safe_get("wl0_hwaddr");
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     mac, strlen(mac));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0mac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwanlink(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    int dhcpstatus;
    switch(reqinfo->mode) {

        case MODE_GET:
            if(nvram_match("wan_dhcp_status", "complete"))
                dhcpstatus = WANDHCPOK;
            else if(nvram_match("wan_dhcp_status", "down"))
                dhcpstatus = WANDHCPNOK;

            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     dhcpstatus);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwanlink\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwanip(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("wan0_ipaddr");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwanip\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwanmask(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("wan0_netmask");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwanmask\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwandns1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("wan0_dns");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwandns1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwandns2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("wan0_dns");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwandns2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwflanmac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        char *mac;
        case MODE_GET:
            mac = nvram_safe_get("lan_hwaddr");
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     mac,
                                     strlen(mac));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwflanmac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwflanip(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("lan_ipaddr");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwflanip\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwflanmask(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct in_addr addr;
    char *pval;
    switch(reqinfo->mode) {

        case MODE_GET:
            pval = nvram_safe_get("lan_netmask");
            if(inet_aton(pval, &addr))
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            else
            {
                memset(&addr, 0, sizeof(addr));
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                        &addr.s_addr, sizeof(addr.s_addr));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwflanmask\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_lwfwifi0wpsenable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0wpsenable\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0wpspin(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0wpspin\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0wpsstart(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0wpsstart\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0wpsstatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0wpsstatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lwfwifi0wdsremotemac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfwifi0wdsremotemac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
handle_lwfapplysettings(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                     applysettingstatus);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (0/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:

            if (*requests->requestvb->val.integer != APPLYSETTINGS) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            else{
                eval("nvram", "commit");
                sys_restart();
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (0/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lwfapplysettings\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initialize the dhcpclientTable table by defining its contents and how it's structured */
    void
initialize_table_dhcpclientTable(void)
{
    const oid dhcpclientTable_oid[] = {1,3,6,1,4,1,33898,1,1,1,48};
    const size_t dhcpclientTable_oid_len   = OID_LENGTH(dhcpclientTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("lwfstb:init", "initializing table dhcpclientTable\n"));

    reg = netsnmp_create_handler_registration(
            "dhcpclientTable",     dhcpclientTable_handler,
            dhcpclientTable_oid, dhcpclientTable_oid_len,
            HANDLER_CAN_RWRITE
            );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
            ASN_INTEGER,  /* index: clientindex */
            0);
    table_info->min_column = COLUMN_CLIENTINDEX;
    table_info->max_column = COLUMN_CLIENTLEASETIME;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = dhcpclientTable_get_first_data_point;
    iinfo->get_next_data_point  = dhcpclientTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;

    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
    buildhcpclienttable();
}

/* Typical data structure for a row entry */
struct dhcpclientTable_entry {
    /* Index values */
    long clientindex;

    /* Column values */
    char clientmac[MACADDRSTRLEN];
    in_addr_t clientip;
    u_long clientleasetime;

    /* Illustrate using a simple linked list */
    int   valid;
    struct dhcpclientTable_entry *next;
};

struct dhcpclientTable_entry  *dhcpclientTable_head;

/* create a new row in the (unsorted) table */
struct dhcpclientTable_entry * 
dhcpclientTable_createEntry(long  clientindex)
{
    struct dhcpclientTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct dhcpclientTable_entry);
    if (!entry)
        return NULL;

    entry->clientindex = clientindex;
    entry->next = dhcpclientTable_head;
    dhcpclientTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
dhcpclientTable_removeEntry( struct dhcpclientTable_entry *entry ) {
    struct dhcpclientTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = dhcpclientTable_head, prev = NULL;
            ptr != NULL;
            prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        dhcpclientTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
    netsnmp_variable_list *
dhcpclientTable_get_first_data_point(void **my_loop_context,
        void **my_data_context,
        netsnmp_variable_list *put_index_data,
        netsnmp_iterator_info *mydata)
{
    buildhcpclienttable();
    *my_loop_context = dhcpclientTable_head;
    return dhcpclientTable_get_next_data_point(my_loop_context, my_data_context,
            put_index_data,  mydata );
}

    netsnmp_variable_list *
dhcpclientTable_get_next_data_point(void **my_loop_context,
        void **my_data_context,
        netsnmp_variable_list *put_index_data,
        netsnmp_iterator_info *mydata)
{
    struct dhcpclientTable_entry *entry = (struct dhcpclientTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->clientindex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

static char *
reltime_short(unsigned int seconds)
{
	static char buf[16];

	sprintf(buf, "%02d:%02d:%02d",
	        seconds / 3600,
	        (seconds % 3600) / 60,
	        seconds % 60);

	return buf;
}

void buildhcpclienttable()
{
    int i, index=0;
    char sigusr1[] = "-XX";
    struct lease_t lease;
    struct dhcpclientTable_entry *entry;
    FILE *fp = NULL;
    struct timeval now;

    gettimeofday(&now, NULL);

    if((now.tv_sec - builddhcpclienttabletime.tv_sec) < REBUILDTABLEINTERVAL){
        //snmp_log(LOG_INFO, "skip to rebuild dhcp client table\n");
        return;
    }

    builddhcpclienttabletime = now;

    while(entry = dhcpclientTable_head)
        dhcpclientTable_removeEntry(entry);

    /* Write out leases file */
    sprintf(sigusr1, "-%d", SIGUSR1);
    eval("killall", sigusr1, "udhcpd");

    if (!(fp = fopen("/tmp/udhcpd0.leases", "r"))){
        snmp_log(LOG_ERR, "fail to open dhcp lease database\n");
        return;
    }

    while (fread(&lease, sizeof(lease), 1, fp)) {
        /* Do not display reserved leases */
        if (ETHER_ISNULLADDR(lease.chaddr))
            continue;

        entry = dhcpclientTable_createEntry(index++);

        ether_etoa(lease.chaddr, entry->clientmac);
        snmp_log(LOG_ERR, "client mac address:%s\n", entry->clientmac);

        entry->clientip = lease.yiaddr;

        entry->clientleasetime = ntohl(lease.expires);
        snmp_log(LOG_ERR, "remain lease time:%s\n", reltime_short(entry->clientleasetime));
    }

    fclose(fp);
    return;
}

/** handles requests for the dhcpclientTable table */
int
dhcpclientTable_handler(
        netsnmp_mib_handler               *handler,
        netsnmp_handler_registration      *reginfo,
        netsnmp_agent_request_info        *reqinfo,
        netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct dhcpclientTable_entry          *table_entry;

    DEBUGMSGTL(("lwfstb:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
        case MODE_GET:
            for (request=requests; request; request=request->next) {
                table_entry = (struct dhcpclientTable_entry *)
                    netsnmp_extract_iterator_context(request);
                table_info  =     netsnmp_extract_table_info(      request);

                switch (table_info->colnum) {
                    case COLUMN_CLIENTINDEX:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                table_entry->clientindex);
                        break;
                    case COLUMN_CLIENTMAC:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_log(LOG_ERR, "client mac address:%s %d\n", table_entry->clientmac, MACADDRSTRLEN);
                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                table_entry->clientmac,
                                MACADDRSTRLEN);
                        break;
                    case COLUMN_CLIENTIP:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
                                table_entry->clientip);
                        break;
                    case COLUMN_CLIENTLEASETIME:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
                                table_entry->clientleasetime*100);
                        snmp_log(LOG_ERR, "remain lease time:%s\n", reltime_short(table_entry->clientleasetime));
                        break;
                    default:
                        netsnmp_set_request_error(reqinfo, request,
                                SNMP_NOSUCHOBJECT);
                        break;
                }
            }
            break;
    }

    return SNMP_ERR_NOERROR;
}

/** Initialize the wifistationTable table by defining its contents and how it's structured */
    void
initialize_table_wifistationTable(void)
{
    const oid wifistationTable_oid[] = {1,3,6,1,4,1,33898,1,1,1,49};
    const size_t wifistationTable_oid_len   = OID_LENGTH(wifistationTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("lwfstb:init", "initializing table wifistationTable\n"));

    reg = netsnmp_create_handler_registration(
            "wifistationTable",     wifistationTable_handler,
            wifistationTable_oid, wifistationTable_oid_len,
            HANDLER_CAN_RWRITE
            );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
            ASN_INTEGER,  /* index: stationindex */
            0);
    table_info->min_column = COLUMN_STATIONINDEX;
    table_info->max_column = COLUMN_ASSOCTIME;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = wifistationTable_get_first_data_point;
    iinfo->get_next_data_point  = wifistationTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;

    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
    buildwifistationtable();
}

/* Typical data structure for a row entry */
struct wifistationTable_entry {
    /* Index values */
    long stationindex;

    /* Column values */
    char stationmac[MACADDRSTRLEN];
    u_long assoctime;

    /* Illustrate using a simple linked list */
    int   valid;
    struct wifistationTable_entry *next;
};

struct wifistationTable_entry  *wifistationTable_head;

/* create a new row in the (unsorted) table */
struct wifistationTable_entry *
wifistationTable_createEntry(long  stationindex) {
    struct wifistationTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct wifistationTable_entry);
    if (!entry)
        return NULL;

    entry->stationindex = stationindex;
    entry->next = wifistationTable_head;
    wifistationTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
wifistationTable_removeEntry( struct wifistationTable_entry *entry ) {
    struct wifistationTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = wifistationTable_head, prev = NULL;
            ptr != NULL;
            prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        wifistationTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
    netsnmp_variable_list *
wifistationTable_get_first_data_point(void **my_loop_context,
        void **my_data_context,
        netsnmp_variable_list *put_index_data,
        netsnmp_iterator_info *mydata)
{
    buildwifistationtable();
    *my_loop_context = wifistationTable_head;
    return wifistationTable_get_next_data_point(my_loop_context, my_data_context,
            put_index_data,  mydata );
}

    netsnmp_variable_list *
wifistationTable_get_next_data_point(void **my_loop_context,
        void **my_data_context,
        netsnmp_variable_list *put_index_data,
        netsnmp_iterator_info *mydata)
{
    struct wifistationTable_entry *entry = (struct wifistationTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->stationindex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

void buildwifistationtable()
{
    int mac_list_size, i;
	char buf[sizeof(sta_info_t)];
	char *ifname;
    char ea_str[MACADDRSTRLEN];
    struct maclist *mac_list;
    struct wifistationTable_entry *entry;
    struct timeval now;

#if 1
    gettimeofday(&now, NULL);

    if((now.tv_sec - buildwifistationtabletime.tv_sec) < REBUILDTABLEINTERVAL){
        //snmp_log(LOG_INFO, "skip to rebuild wifi station table\n");
        return;
    }

    buildwifistationtabletime = now;
#endif

    while(entry = wifistationTable_head)
        wifistationTable_removeEntry(entry);

    mac_list_size = sizeof(mac_list->count) + MAX_STA_COUNT * sizeof(struct ether_addr);
    mac_list = malloc(mac_list_size);

    if (!mac_list){
        snmp_log(LOG_ERR, "fail to allocate mac list buffer\n");
        return;
    }

    ifname = nvram_safe_get("wl0_ifname");
    if(!strcmp(ifname, "")){
        free(mac_list);
        snmp_log(LOG_ERR, "fail to get wireless interface name\n");
        return;
    }

    strcpy((char*)mac_list, "authe_sta_list");
    if (wl_ioctl(ifname, WLC_GET_VAR, mac_list, mac_list_size)) {
        free(mac_list);
        snmp_log(LOG_ERR, "fail to get mac list from wifi driver\n");
        return;
    }

    for (i = 0; i < mac_list->count; i++) {
        bzero(buf, sizeof(buf));
        strcpy(buf, "sta_info");
        memcpy(buf + strlen(buf) + 1,(unsigned char *) &(mac_list->ea[i]), ETHER_ADDR_LEN);

        if (!wl_ioctl(ifname, WLC_GET_VAR, buf, sizeof(buf))) {
            sta_info_t *sta = (sta_info_t *)buf;
            uint32 f = sta->flags;

            bzero(ea_str, sizeof(ea_str));
            ether_etoa((unsigned char *)&mac_list->ea[i], ea_str);

            entry = wifistationTable_createEntry(i);
            memcpy(entry->stationmac,ea_str, MACADDRSTRLEN);
            entry->assoctime = sta->in;
        }
    }
    free(mac_list);

    return;
}

/** handles requests for the wifistationTable table */
int
wifistationTable_handler(
        netsnmp_mib_handler               *handler,
        netsnmp_handler_registration      *reginfo,
        netsnmp_agent_request_info        *reqinfo,
        netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct wifistationTable_entry          *table_entry;

    DEBUGMSGTL(("lwfstb:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
        case MODE_GET:
            for (request=requests; request; request=request->next) {
                table_entry = (struct wifistationTable_entry *)
                    netsnmp_extract_iterator_context(request);
                table_info  =     netsnmp_extract_table_info(      request);

                switch (table_info->colnum) {
                    case COLUMN_STATIONINDEX:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                table_entry->stationindex);
                        break;
                    case COLUMN_STATIONMAC:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                table_entry->stationmac,
                                MACADDRSTRLEN);
                        break;
                    case COLUMN_ASSOCTIME:
                        if ( !table_entry ) {
                            netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
                            continue;
                        }
                        snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
                                table_entry->assoctime*100);
                        break;
                    default:
                        netsnmp_set_request_error(reqinfo, request,
                                SNMP_NOSUCHOBJECT);
                        break;
                }
            }
            break;
    }

    return SNMP_ERR_NOERROR;
}
