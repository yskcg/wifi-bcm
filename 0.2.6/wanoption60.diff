--- a/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.c
+++ b/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.c
@@ -81,10 +81,10 @@ bool setwlencryptionmethod(int encryptmode, char *wlnameprefix, struct wirelessT
 bool getwlsecmethod(long *secmode, char *wlnameprefix);
 
 struct lease_t {
-	unsigned char chaddr[16];
-	u_int32_t yiaddr;
-	u_int32_t expires;
-	char hostname[64];
+    unsigned char chaddr[16];
+    u_int32_t yiaddr;
+    u_int32_t expires;
+    char hostname[64];
 };
 
 void buildvlantable();
@@ -94,100 +94,100 @@ void buildvidtable();
 
 inline void sys_reboot(void)
 {
-	eval("wl", "reboot");
-	kill(1, SIGTERM);
+    eval("wl", "reboot");
+    kill(1, SIGTERM);
 }
 
 void del_iQosRules(void)
 {
-	/* Flush all rules in mangle table */
-	eval("iptables", "-t", "mangle", "-F");
+    /* Flush all rules in mangle table */
+    eval("iptables", "-t", "mangle", "-F");
 }
 
 int ifconfig(char *name, int flags, char *addr, char *netmask)
 {
-	int s;
-	struct ifreq ifr;
-	struct in_addr in_addr, in_netmask, in_broadaddr;
-
-	/* Open a raw socket to the kernel */
-	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
-		goto err;
-
-	/* Set interface name */
-	strncpy(ifr.ifr_name, name, IFNAMSIZ);
-	
-	/* Set interface flags */
-	ifr.ifr_flags = flags;
-	if (ioctl(s, SIOCSIFFLAGS, &ifr) < 0)
-		goto err;
-	
-	/* Set IP address */
-	if (addr) {
-		inet_aton(addr, &in_addr);
-		sin_addr(&ifr.ifr_addr).s_addr = in_addr.s_addr;
-		ifr.ifr_addr.sa_family = AF_INET;
-		if (ioctl(s, SIOCSIFADDR, &ifr) < 0)
-			goto err;
-	}
-
-	/* Set IP netmask and broadcast */
-	if (addr && netmask) {
-		inet_aton(netmask, &in_netmask);
-		sin_addr(&ifr.ifr_netmask).s_addr = in_netmask.s_addr;
-		ifr.ifr_netmask.sa_family = AF_INET;
-		if (ioctl(s, SIOCSIFNETMASK, &ifr) < 0)
-			goto err;
-
-		in_broadaddr.s_addr = (in_addr.s_addr & in_netmask.s_addr) | ~in_netmask.s_addr;
-		sin_addr(&ifr.ifr_broadaddr).s_addr = in_broadaddr.s_addr;
-		ifr.ifr_broadaddr.sa_family = AF_INET;
-		if (ioctl(s, SIOCSIFBRDADDR, &ifr) < 0)
-			goto err;
-	}
-
-	close(s);
-
-	return 0;
-
- err:
-	close(s);
-	perror(name);
-	return errno;
+    int s;
+    struct ifreq ifr;
+    struct in_addr in_addr, in_netmask, in_broadaddr;
+
+    /* Open a raw socket to the kernel */
+    if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
+        goto err;
+
+    /* Set interface name */
+    strncpy(ifr.ifr_name, name, IFNAMSIZ);
+
+    /* Set interface flags */
+    ifr.ifr_flags = flags;
+    if (ioctl(s, SIOCSIFFLAGS, &ifr) < 0)
+        goto err;
+
+    /* Set IP address */
+    if (addr) {
+        inet_aton(addr, &in_addr);
+        sin_addr(&ifr.ifr_addr).s_addr = in_addr.s_addr;
+        ifr.ifr_addr.sa_family = AF_INET;
+        if (ioctl(s, SIOCSIFADDR, &ifr) < 0)
+            goto err;
+    }
+
+    /* Set IP netmask and broadcast */
+    if (addr && netmask) {
+        inet_aton(netmask, &in_netmask);
+        sin_addr(&ifr.ifr_netmask).s_addr = in_netmask.s_addr;
+        ifr.ifr_netmask.sa_family = AF_INET;
+        if (ioctl(s, SIOCSIFNETMASK, &ifr) < 0)
+            goto err;
+
+        in_broadaddr.s_addr = (in_addr.s_addr & in_netmask.s_addr) | ~in_netmask.s_addr;
+        sin_addr(&ifr.ifr_broadaddr).s_addr = in_broadaddr.s_addr;
+        ifr.ifr_broadaddr.sa_family = AF_INET;
+        if (ioctl(s, SIOCSIFBRDADDR, &ifr) < 0)
+            goto err;
+    }
+
+    close(s);
+
+    return 0;
+
+err:
+    close(s);
+    perror(name);
+    return errno;
 }	
 
 void stop_wan(void)
 {
-	char name[80], *next, signal[] = "XXXX";
-	
+    char name[80], *next, signal[] = "XXXX";
+
 #ifdef BCMQOS
-		del_iQosRules();
+    del_iQosRules();
 #endif /* BCMQOS */
-	eval("killall", "stats");
-	eval("killall", "ntpclient");
-
-	/* Shutdown and kill all possible tasks */
-	eval("killall", "ip-up");
-	eval("killall", "ip-down");
-	snprintf(signal, sizeof(signal), "-%d", SIGHUP);
-	eval("killall", signal, "pppoecd");
-	eval("killall", "pppoecd");
-	snprintf(signal, sizeof(signal), "-%d", SIGUSR2);
-	eval("killall", signal, "udhcpc");
-	eval("killall", "udhcpc");
-
-	/* Bring down WAN interfaces */
-	foreach(name, nvram_safe_get("wan_ifnames"), next)
-		ifconfig(name, 0, "0.0.0.0", NULL);
-
-	/* Remove dynamically created links */
-	unlink("/tmp/udhcpc");
-	
-	unlink("/tmp/ppp/ip-up");
-	unlink("/tmp/ppp/ip-down");
-	rmdir("/tmp/ppp");
-
-	dprintf("done\n");
+    eval("killall", "stats");
+    eval("killall", "ntpclient");
+
+    /* Shutdown and kill all possible tasks */
+    eval("killall", "ip-up");
+    eval("killall", "ip-down");
+    snprintf(signal, sizeof(signal), "-%d", SIGHUP);
+    eval("killall", signal, "pppoecd");
+    eval("killall", "pppoecd");
+    snprintf(signal, sizeof(signal), "-%d", SIGUSR2);
+    eval("killall", signal, "udhcpc");
+    eval("killall", "udhcpc");
+
+    /* Bring down WAN interfaces */
+    foreach(name, nvram_safe_get("wan_ifnames"), next)
+        ifconfig(name, 0, "0.0.0.0", NULL);
+
+    /* Remove dynamically created links */
+    unlink("/tmp/udhcpc");
+
+    unlink("/tmp/ppp/ip-up");
+    unlink("/tmp/ppp/ip-down");
+    rmdir("/tmp/ppp");
+
+    dprintf("done\n");
 }
 
 bool updatedefaultgw(char *ipaddr, char *netmask)
@@ -204,7 +204,7 @@ bool updatedefaultgw(char *ipaddr, char *netmask)
     inet_aton(gws, &gw);
 
     if((gw.s_addr & mask.s_addr) != (lanip.s_addr & mask.s_addr)){
-        
+
         gw.s_addr = htonl(ntohl((lanip.s_addr & mask.s_addr)) | 0x01);
 
         bzero(gws,sizeof(gws));
@@ -234,7 +234,7 @@ bool updatedhcpaddress(char *ipaddr, char *netmask)
     inet_aton(tmpbuf, &dhcpend);
 
     if(((dhcpstart.s_addr & mask.s_addr) != ( lanip.s_addr & mask.s_addr )) || \
-           ((dhcpend.s_addr & mask.s_addr) != ( lanip.s_addr & mask.s_addr ))){
+            ((dhcpend.s_addr & mask.s_addr) != ( lanip.s_addr & mask.s_addr ))){
 
         if(~(ntohl(mask.s_addr)) < DHCPMINIMUMPOOLSIZE )
             return false;
@@ -287,7 +287,7 @@ int nvram_nset(const char *name, const char *value, const int length)
 }
 
 /** Initializes the gxgdWiFiModule module */
-void
+    void
 init_gxgdWiFiModule(void)
 {
     const oid loginusername_oid[] = { 1,3,6,1,4,1,46227,2,2,1,1,1 };
@@ -307,6 +307,7 @@ init_gxgdWiFiModule(void)
     const oid pppoeconnectionstatus_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,25 };
     const oid pppoeon_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,27 };
     const oid wanon_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,28 };
+    const oid wandhcpoption60_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,29 };
     const oid wirelessmode_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,30 };
     const oid pppoeconnectondemand_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,31 };
     const oid pppoedisconnect_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,33 };
@@ -347,282 +348,287 @@ init_gxgdWiFiModule(void)
 #endif
     const oid vlanenabled_oid[] = { 1,3,6,1,4,1,46227,2,3,1,1,45 };
 
-  DEBUGMSGTL(("gxgdWiFiModule", "Initializing\n"));
+    DEBUGMSGTL(("gxgdWiFiModule", "Initializing\n"));
 
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("loginusername", handle_loginusername,
-                               loginusername_oid, OID_LENGTH(loginusername_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("loginusername", handle_loginusername,
+                loginusername_oid, OID_LENGTH(loginusername_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("loginpassword", handle_loginpassword,
-                               loginpassword_oid, OID_LENGTH(loginpassword_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("loginpassword", handle_loginpassword,
+                loginpassword_oid, OID_LENGTH(loginpassword_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("lanipaddress", handle_lanipaddress,
-                               lanipaddress_oid, OID_LENGTH(lanipaddress_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("lanipaddress", handle_lanipaddress,
+                lanipaddress_oid, OID_LENGTH(lanipaddress_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("lannetmask", handle_lannetmask,
-                               lannetmask_oid, OID_LENGTH(lannetmask_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("lannetmask", handle_lannetmask,
+                lannetmask_oid, OID_LENGTH(lannetmask_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("reset", handle_reset,
-                               reset_oid, OID_LENGTH(reset_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("reset", handle_reset,
+                reset_oid, OID_LENGTH(reset_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("factoryrestore", handle_factoryrestore,
-                               factoryrestore_oid, OID_LENGTH(factoryrestore_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("factoryrestore", handle_factoryrestore,
+                factoryrestore_oid, OID_LENGTH(factoryrestore_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("txpower", handle_txpower,
-                               txpower_oid, OID_LENGTH(txpower_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("txpower", handle_txpower,
+                txpower_oid, OID_LENGTH(txpower_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wifimode", handle_wifimode,
-                               wifimode_oid, OID_LENGTH(wifimode_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wifimode", handle_wifimode,
+                wifimode_oid, OID_LENGTH(wifimode_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("channel", handle_channel,
-                               channel_oid, OID_LENGTH(channel_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("channel", handle_channel,
+                channel_oid, OID_LENGTH(channel_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("ssidnumber", handle_ssidnumber,
-                               ssidnumber_oid, OID_LENGTH(ssidnumber_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("ssidnumber", handle_ssidnumber,
+                ssidnumber_oid, OID_LENGTH(ssidnumber_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("applysettings", handle_applysettings,
-                               applysettings_oid, OID_LENGTH(applysettings_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("applysettings", handle_applysettings,
+                applysettings_oid, OID_LENGTH(applysettings_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoeusername", handle_pppoeusername,
-                               pppoeusername_oid, OID_LENGTH(pppoeusername_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoeusername", handle_pppoeusername,
+                pppoeusername_oid, OID_LENGTH(pppoeusername_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoepassword", handle_pppoepassword,
-                               pppoepassword_oid, OID_LENGTH(pppoepassword_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoepassword", handle_pppoepassword,
+                pppoepassword_oid, OID_LENGTH(pppoepassword_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoeservicename", handle_pppoeservicename,
-                               pppoeservicename_oid, OID_LENGTH(pppoeservicename_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoeservicename", handle_pppoeservicename,
+                pppoeservicename_oid, OID_LENGTH(pppoeservicename_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoeconnectionstatus", handle_pppoeconnectionstatus,
-                               pppoeconnectionstatus_oid, OID_LENGTH(pppoeconnectionstatus_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("pppoeconnectionstatus", handle_pppoeconnectionstatus,
+                pppoeconnectionstatus_oid, OID_LENGTH(pppoeconnectionstatus_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoeon", handle_pppoeon,
-                               pppoeon_oid, OID_LENGTH(pppoeon_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoeon", handle_pppoeon,
+                pppoeon_oid, OID_LENGTH(pppoeon_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanon", handle_wanon,
-                               wanon_oid, OID_LENGTH(wanon_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanon", handle_wanon,
+                wanon_oid, OID_LENGTH(wanon_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wirelessmode", handle_wirelessmode,
-                               wirelessmode_oid, OID_LENGTH(wirelessmode_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wandhcpoption60", handle_wandhcpoption60,
+                wandhcpoption60_oid, OID_LENGTH(wandhcpoption60_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoeconnectondemand", handle_pppoeconnectondemand,
-                               pppoeconnectondemand_oid, OID_LENGTH(pppoeconnectondemand_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wirelessmode", handle_wirelessmode,
+                wirelessmode_oid, OID_LENGTH(wirelessmode_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("pppoedisconnect", handle_pppoedisconnect,
-                               pppoedisconnect_oid, OID_LENGTH(pppoedisconnect_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoeconnectondemand", handle_pppoeconnectondemand,
+                pppoeconnectondemand_oid, OID_LENGTH(pppoeconnectondemand_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wpsenable", handle_wpsenable,
-                               wpsenable_oid, OID_LENGTH(wpsenable_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("pppoedisconnect", handle_pppoedisconnect,
+                pppoedisconnect_oid, OID_LENGTH(pppoedisconnect_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpenable", handle_dhcpenable,
-                               dhcpenable_oid, OID_LENGTH(dhcpenable_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wpsenable", handle_wpsenable,
+                wpsenable_oid, OID_LENGTH(wpsenable_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpaddresstart", handle_dhcpaddresstart,
-                               dhcpaddresstart_oid, OID_LENGTH(dhcpaddresstart_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpenable", handle_dhcpenable,
+                dhcpenable_oid, OID_LENGTH(dhcpenable_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpaddressend", handle_dhcpaddressend,
-                               dhcpaddressend_oid, OID_LENGTH(dhcpaddressend_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpaddresstart", handle_dhcpaddresstart,
+                dhcpaddresstart_oid, OID_LENGTH(dhcpaddresstart_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpnetmask", handle_dhcpnetmask,
-                               dhcpnetmask_oid, OID_LENGTH(dhcpnetmask_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpaddressend", handle_dhcpaddressend,
+                dhcpaddressend_oid, OID_LENGTH(dhcpaddressend_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpgateway", handle_dhcpgateway,
-                               dhcpgateway_oid, OID_LENGTH(dhcpgateway_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpnetmask", handle_dhcpnetmask,
+                dhcpnetmask_oid, OID_LENGTH(dhcpnetmask_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("dhcpleasetime", handle_dhcpleasetime,
-                               dhcpleasetime_oid, OID_LENGTH(dhcpleasetime_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpgateway", handle_dhcpgateway,
+                dhcpgateway_oid, OID_LENGTH(dhcpgateway_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wifibandwidth", handle_wifibandwidth,
-                               wifibandwidth_oid, OID_LENGTH(wifibandwidth_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("dhcpleasetime", handle_dhcpleasetime,
+                dhcpleasetime_oid, OID_LENGTH(dhcpleasetime_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanipaddress", handle_wanipaddress,
-                               wanipaddress_oid, OID_LENGTH(wanipaddress_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wifibandwidth", handle_wifibandwidth,
+                wifibandwidth_oid, OID_LENGTH(wifibandwidth_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wannetmask", handle_wannetmask,
-                               wannetmask_oid, OID_LENGTH(wannetmask_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wanipaddress", handle_wanipaddress,
+                wanipaddress_oid, OID_LENGTH(wanipaddress_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wangateway", handle_wangateway,
-                               wangateway_oid, OID_LENGTH(wangateway_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wannetmask", handle_wannetmask,
+                wannetmask_oid, OID_LENGTH(wannetmask_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wandns", handle_wandns,
-                               wandns_oid, OID_LENGTH(wandns_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wangateway", handle_wangateway,
+                wangateway_oid, OID_LENGTH(wangateway_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanseconddns", handle_wanseconddns,
-                               wanseconddns_oid, OID_LENGTH(wanseconddns_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wandns", handle_wandns,
+                wandns_oid, OID_LENGTH(wandns_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanconnectionstatus", handle_wanconnectionstatus,
-                               wanconnectionstatus_oid, OID_LENGTH(wanconnectionstatus_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wanseconddns", handle_wanseconddns,
+                wanseconddns_oid, OID_LENGTH(wanseconddns_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wantype", handle_wantype,
-                               wantype_oid, OID_LENGTH(wantype_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanconnectionstatus", handle_wanconnectionstatus,
+                wanconnectionstatus_oid, OID_LENGTH(wanconnectionstatus_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanmacaddress", handle_wanmacaddress,
-                               wanmacaddress_oid, OID_LENGTH(wanmacaddress_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wantype", handle_wantype,
+                wantype_oid, OID_LENGTH(wantype_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("lanmacaddress", handle_lanmacaddress,
-                               lanmacaddress_oid, OID_LENGTH(lanmacaddress_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wanmacaddress", handle_wanmacaddress,
+                wanmacaddress_oid, OID_LENGTH(wanmacaddress_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanstaticipaddress", handle_wanstaticipaddress,
-                               wanstaticipaddress_oid, OID_LENGTH(wanstaticipaddress_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("lanmacaddress", handle_lanmacaddress,
+                lanmacaddress_oid, OID_LENGTH(lanmacaddress_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanstaticnetmask", handle_wanstaticnetmask,
-                               wanstaticnetmask_oid, OID_LENGTH(wanstaticnetmask_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanstaticipaddress", handle_wanstaticipaddress,
+                wanstaticipaddress_oid, OID_LENGTH(wanstaticipaddress_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanstaticgateway", handle_wanstaticgateway,
-                               wanstaticgateway_oid, OID_LENGTH(wanstaticgateway_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanstaticnetmask", handle_wanstaticnetmask,
+                wanstaticnetmask_oid, OID_LENGTH(wanstaticnetmask_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanstaticdns", handle_wanstaticdns,
-                               wanstaticdns_oid, OID_LENGTH(wanstaticdns_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanstaticgateway", handle_wanstaticgateway,
+                wanstaticgateway_oid, OID_LENGTH(wanstaticgateway_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("wanstaticdns2", handle_wanstaticdns2,
-                               wanstaticdns2_oid, OID_LENGTH(wanstaticdns2_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("wanstaticdns", handle_wanstaticdns,
+                wanstaticdns_oid, OID_LENGTH(wanstaticdns_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("manufacture", handle_manufacture,
-                               manufacture_oid, OID_LENGTH(manufacture_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("wanstaticdns2", handle_wanstaticdns2,
+                wanstaticdns2_oid, OID_LENGTH(wanstaticdns2_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("hardwaremodel", handle_hardwaremodel,
-                               hardwaremodel_oid, OID_LENGTH(hardwaremodel_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("manufacture", handle_manufacture,
+                manufacture_oid, OID_LENGTH(manufacture_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("softwareversion", handle_softwareversion,
-                               softwareversion_oid, OID_LENGTH(softwareversion_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("hardwaremodel", handle_hardwaremodel,
+                hardwaremodel_oid, OID_LENGTH(hardwaremodel_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("upgradingstart", handle_upgradingstart,
-                               upgradingstart_oid, OID_LENGTH(upgradingstart_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("softwareversion", handle_softwareversion,
+                softwareversion_oid, OID_LENGTH(softwareversion_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("rebootafterupgrading", handle_rebootafterupgrading,
-                               rebootafterupgrading_oid, OID_LENGTH(rebootafterupgrading_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("upgradingstart", handle_upgradingstart,
+                upgradingstart_oid, OID_LENGTH(upgradingstart_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("imagefilename", handle_imagefilename,
-                               imagefilename_oid, OID_LENGTH(imagefilename_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("rebootafterupgrading", handle_rebootafterupgrading,
+                rebootafterupgrading_oid, OID_LENGTH(rebootafterupgrading_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("serverip", handle_serverip,
-                               serverip_oid, OID_LENGTH(serverip_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("imagefilename", handle_imagefilename,
+                imagefilename_oid, OID_LENGTH(imagefilename_oid),
+                HANDLER_CAN_RWRITE
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("serverport", handle_serverport,
-                               serverport_oid, OID_LENGTH(serverport_oid),
-                               HANDLER_CAN_RWRITE
-        ));
+            netsnmp_create_handler_registration("serverip", handle_serverip,
+                serverip_oid, OID_LENGTH(serverip_oid),
+                HANDLER_CAN_RWRITE
+                ));
+    netsnmp_register_scalar(
+            netsnmp_create_handler_registration("serverport", handle_serverport,
+                serverport_oid, OID_LENGTH(serverport_oid),
+                HANDLER_CAN_RWRITE
+                ));
 #if 0
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("vlanenabled", handle_vlanenabled,
-                               vlanenabled_oid, OID_LENGTH(vlanenabled_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("vlanenabled", handle_vlanenabled,
+                vlanenabled_oid, OID_LENGTH(vlanenabled_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("bridgedvlanid", handle_bridgedvlanid,
-                               bridgedvlanid_oid, OID_LENGTH(bridgedvlanid_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("bridgedvlanid", handle_bridgedvlanid,
+                bridgedvlanid_oid, OID_LENGTH(bridgedvlanid_oid),
+                HANDLER_CAN_RONLY
+                ));
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("natvlanid", handle_natvlanid,
-                               natvlanid_oid, OID_LENGTH(natvlanid_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("natvlanid", handle_natvlanid,
+                natvlanid_oid, OID_LENGTH(natvlanid_oid),
+                HANDLER_CAN_RONLY
+                ));
 #endif
     netsnmp_register_scalar(
-        netsnmp_create_handler_registration("vlanenabled", handle_vlanenabled,
-                               vlanenabled_oid, OID_LENGTH(vlanenabled_oid),
-                               HANDLER_CAN_RONLY
-        ));
+            netsnmp_create_handler_registration("vlanenabled", handle_vlanenabled,
+                vlanenabled_oid, OID_LENGTH(vlanenabled_oid),
+                HANDLER_CAN_RONLY
+                ));
 
-  /* here we initialize all the tables we're planning on supporting */
+    /* here we initialize all the tables we're planning on supporting */
     initialize_table_wirelessTable();
     initialize_table_dhcpclientTable();
     initialize_table_wifistationTable();
@@ -630,11 +636,11 @@ init_gxgdWiFiModule(void)
     initialize_table_vidTable();
 }
 
-int
+    int
 handle_loginusername(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -643,7 +649,7 @@ handle_loginusername(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -654,14 +660,14 @@ handle_loginusername(netsnmp_mib_handler *handler,
                         pval, length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -715,11 +721,11 @@ handle_loginusername(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_loginpassword(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -729,7 +735,7 @@ handle_loginpassword(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -740,14 +746,14 @@ handle_loginpassword(netsnmp_mib_handler *handler,
                         pval, length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -802,11 +808,11 @@ handle_loginpassword(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_lanipaddress(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
@@ -834,14 +840,14 @@ handle_lanipaddress(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -908,11 +914,11 @@ handle_lanipaddress(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_lannetmask(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
@@ -940,14 +946,14 @@ handle_lannetmask(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1013,11 +1019,11 @@ handle_lannetmask(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_reset(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1025,22 +1031,22 @@ handle_reset(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     SNMPFALSE);
+                    SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1091,11 +1097,11 @@ handle_reset(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_factoryrestore(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1103,22 +1109,22 @@ handle_factoryrestore(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     SNMPFALSE);
+                    SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1206,11 +1212,11 @@ bool settxpower(int power)
     return true;
 }
 
-int
+    int
 handle_txpower(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     char *pval;
@@ -1221,7 +1227,7 @@ handle_txpower(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -1229,20 +1235,20 @@ handle_txpower(netsnmp_mib_handler *handler,
 
             if(txpower > 0 && txpower < 100)
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     txpower);
+                        txpower);
             else
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     100);
+                        100);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1297,11 +1303,11 @@ handle_txpower(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wifimode(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1309,22 +1315,22 @@ handle_wifimode(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     WIFI_80211bgn);
+                    WIFI_80211bgn);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1345,7 +1351,7 @@ handle_wifimode(netsnmp_mib_handler *handler,
             break;
 
         case MODE_SET_ACTION:
-                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOTWRITABLE);
+            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOTWRITABLE);
             break;
 
         case MODE_SET_COMMIT:
@@ -1373,11 +1379,11 @@ handle_wifimode(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_channel(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     char *pchan;
@@ -1388,7 +1394,7 @@ handle_channel(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -1397,20 +1403,20 @@ handle_channel(netsnmp_mib_handler *handler,
 
             if(fchan <= 13 && fchan >= 1)
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     fchan);
+                        fchan);
             else
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     0);
+                        0);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1472,11 +1478,11 @@ handle_channel(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_ssidnumber(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1484,7 +1490,7 @@ handle_ssidnumber(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -1504,11 +1510,11 @@ handle_ssidnumber(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_applysettings(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1516,21 +1522,21 @@ handle_applysettings(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1552,8 +1558,8 @@ handle_applysettings(netsnmp_mib_handler *handler,
 
         case MODE_SET_ACTION:
             if (*requests->requestvb->val.integer != APPLY_ALLSETTINGS &&
-                *requests->requestvb->val.integer != APPLY_WIFISETTINGS &&
-                *requests->requestvb->val.integer != APPLY_WANSETTINGS ) {
+                    *requests->requestvb->val.integer != APPLY_WIFISETTINGS &&
+                    *requests->requestvb->val.integer != APPLY_WANSETTINGS ) {
                 netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
             }
             else{
@@ -1587,11 +1593,11 @@ handle_applysettings(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoeusername(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -1600,24 +1606,24 @@ handle_pppoeusername(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             pval = nvram_safe_get("wan_pppoe_username");
             length = strlen(pval);
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                     pval, length);
+                    pval, length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1671,11 +1677,11 @@ handle_pppoeusername(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoepassword(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -1684,24 +1690,24 @@ handle_pppoepassword(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             pval = nvram_safe_get("wan_pppoe_passwd");
             length = strlen(pval);
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                    pval,length);
+                    pval,length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1755,11 +1761,11 @@ handle_pppoepassword(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoeservicename(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -1768,7 +1774,7 @@ handle_pppoeservicename(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -1777,14 +1783,14 @@ handle_pppoeservicename(netsnmp_mib_handler *handler,
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, pval, length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1806,7 +1812,7 @@ handle_pppoeservicename(netsnmp_mib_handler *handler,
 
         case MODE_SET_ACTION:
             nvram_nset("wan_pppoe_service",requests->requestvb->val.string, \
-                        requests->requestvb->val_len);
+                    requests->requestvb->val_len);
             break;
 
         case MODE_SET_COMMIT:
@@ -1834,11 +1840,11 @@ handle_pppoeservicename(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoeconnectionstatus(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, pppoest;
     char *wan_ifname;
@@ -1849,7 +1855,7 @@ handle_pppoeconnectionstatus(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -1879,11 +1885,11 @@ handle_pppoeconnectionstatus(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoeon(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1891,21 +1897,21 @@ handle_pppoeon(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -1961,11 +1967,11 @@ handle_pppoeon(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanon(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -1973,21 +1979,21 @@ handle_wanon(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2042,11 +2048,90 @@ handle_wanon(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
+handle_wandhcpoption60(netsnmp_mib_handler *handler,
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
+{
+    int ret, length;
+    char *pval;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            pval = nvram_safe_get("wan_dhcpoption60");
+            length = strlen(pval);
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, pval, length);
+            break;
+
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
+        case MODE_SET_RESERVE1:
+            /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0/* XXX if malloc, or whatever, failed: */) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            nvram_nset("wan_dhcpoption60",requests->requestvb->val.string, \
+                    requests->requestvb->val_len);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+            if (0/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if (0/* XXX: error? */) {
+                /* try _really_really_ hard to never get to this point */
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            }
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pppoeservicename\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+    int
 handle_wirelessmode(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -2054,22 +2139,22 @@ handle_wirelessmode(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                    WIFI_ROUTER);
+                    WIFI_ROUTER);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2114,11 +2199,11 @@ handle_wirelessmode(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoeconnectondemand(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length, ondemond;
     char *pval;
@@ -2127,7 +2212,7 @@ handle_pppoeconnectondemand(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2140,14 +2225,14 @@ handle_pppoeconnectondemand(netsnmp_mib_handler *handler,
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,ondemond);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2206,11 +2291,11 @@ handle_pppoeconnectondemand(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_pppoedisconnect(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -2218,21 +2303,21 @@ handle_pppoedisconnect(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2286,11 +2371,11 @@ handle_pppoedisconnect(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wpsenable(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, length;
     char *pval;
@@ -2299,7 +2384,7 @@ handle_wpsenable(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2312,14 +2397,14 @@ handle_wpsenable(netsnmp_mib_handler *handler,
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2377,11 +2462,11 @@ handle_wpsenable(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpenable(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, dhcpenabled;
     /* We are never called for a GETNEXT if it's registered as a
@@ -2389,7 +2474,7 @@ handle_dhcpenable(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2401,14 +2486,14 @@ handle_dhcpenable(netsnmp_mib_handler *handler,
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, dhcpenabled);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2464,11 +2549,11 @@ handle_dhcpenable(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpaddresstart(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -2479,7 +2564,7 @@ handle_dhcpaddresstart(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2497,14 +2582,14 @@ handle_dhcpaddresstart(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2570,11 +2655,11 @@ handle_dhcpaddresstart(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpaddressend(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -2585,7 +2670,7 @@ handle_dhcpaddressend(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2603,14 +2688,14 @@ handle_dhcpaddressend(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2678,11 +2763,11 @@ handle_dhcpaddressend(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpnetmask(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -2693,7 +2778,7 @@ handle_dhcpnetmask(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2711,14 +2796,14 @@ handle_dhcpnetmask(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2782,11 +2867,11 @@ handle_dhcpnetmask(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpgateway(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -2797,7 +2882,7 @@ handle_dhcpgateway(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -2815,14 +2900,14 @@ handle_dhcpgateway(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2890,11 +2975,11 @@ handle_dhcpgateway(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_dhcpleasetime(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, leasetime;
     char *pval;
@@ -2904,24 +2989,24 @@ handle_dhcpleasetime(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             pval = nvram_safe_get("lan_lease");
             leasetime = atoi(pval);
             snmp_set_var_typed_integer(requests->requestvb, ASN_TIMETICKS,
-                                     leasetime * 100);
+                    leasetime * 100);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_TIMETICKS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -2973,11 +3058,11 @@ handle_dhcpleasetime(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wifibandwidth(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, bandwidth;
     char *pnval;
@@ -2987,7 +3072,7 @@ handle_wifibandwidth(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3002,17 +3087,17 @@ handle_wifibandwidth(netsnmp_mib_handler *handler,
 
             if(bandwidth != CHANNEL_NOTSP_BDW)
                 snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     bandwidth);
+                        bandwidth);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3079,11 +3164,11 @@ handle_wifibandwidth(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanipaddress(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3093,7 +3178,7 @@ handle_wanipaddress(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3124,11 +3209,11 @@ handle_wanipaddress(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wannetmask(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3138,7 +3223,7 @@ handle_wannetmask(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3169,11 +3254,11 @@ handle_wannetmask(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wangateway(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3183,7 +3268,7 @@ handle_wangateway(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3214,11 +3299,11 @@ handle_wangateway(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wandns(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3228,7 +3313,7 @@ handle_wandns(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3259,11 +3344,11 @@ handle_wandns(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanseconddns(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3273,7 +3358,7 @@ handle_wanseconddns(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3304,18 +3389,18 @@ handle_wanseconddns(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanconnectionstatus(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     int dhcpstatus;
     switch(reqinfo->mode) {
 
@@ -3326,7 +3411,7 @@ handle_wanconnectionstatus(netsnmp_mib_handler *handler,
                 dhcpstatus = WANDHCPNOK;
 
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     dhcpstatus);
+                    dhcpstatus);
             break;
 
         case MODE_SET_ACTION:
@@ -3343,11 +3428,11 @@ handle_wanconnectionstatus(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wantype(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, wanproto;
     char *pval;
@@ -3356,7 +3441,7 @@ handle_wantype(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3373,14 +3458,14 @@ handle_wantype(netsnmp_mib_handler *handler,
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, wanproto);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3440,11 +3525,11 @@ handle_wantype(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanmacaddress(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     char *mac;
@@ -3453,14 +3538,14 @@ handle_wanmacaddress(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             mac = nvram_safe_get("wan0_hwaddr");
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                     mac,
-                                     strlen(mac));
+                    mac,
+                    strlen(mac));
             break;
 
         case MODE_SET_ACTION:
@@ -3476,11 +3561,11 @@ handle_wanmacaddress(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_lanmacaddress(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     char *mac;
@@ -3489,14 +3574,14 @@ handle_lanmacaddress(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             mac = nvram_safe_get("lan_hwaddr");
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                     mac,
-                                     strlen(mac));
+                    mac,
+                    strlen(mac));
             break;
 
         case MODE_SET_ACTION:
@@ -3512,11 +3597,11 @@ handle_lanmacaddress(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanstaticipaddress(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3526,7 +3611,7 @@ handle_wanstaticipaddress(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3544,14 +3629,14 @@ handle_wanstaticipaddress(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3608,11 +3693,11 @@ handle_wanstaticipaddress(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanstaticnetmask(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3622,7 +3707,7 @@ handle_wanstaticnetmask(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3640,14 +3725,14 @@ handle_wanstaticnetmask(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3704,11 +3789,11 @@ handle_wanstaticnetmask(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanstaticgateway(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3718,7 +3803,7 @@ handle_wanstaticgateway(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3736,14 +3821,14 @@ handle_wanstaticgateway(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3800,11 +3885,11 @@ handle_wanstaticgateway(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanstaticdns(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3814,7 +3899,7 @@ handle_wanstaticdns(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3832,14 +3917,14 @@ handle_wanstaticdns(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3896,11 +3981,11 @@ handle_wanstaticdns(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_wanstaticdns2(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -3910,7 +3995,7 @@ handle_wanstaticdns2(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -3928,14 +4013,14 @@ handle_wanstaticdns2(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -3992,11 +4077,11 @@ handle_wanstaticdns2(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_manufacture(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, manufact = DEFAULT_MANUFACTURE;
     /* We are never called for a GETNEXT if it's registered as a
@@ -4004,7 +4089,7 @@ handle_manufacture(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -4025,23 +4110,23 @@ handle_manufacture(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_hardwaremodel(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                    HARDWAREVER, strlen(HARDWAREVER));
+                    HARDWAREVER, strlen(HARDWAREVER));
             break;
 
 
@@ -4092,11 +4177,11 @@ bool readswversion(char * version)
     return true;
 }
 
-int
+    int
 handle_softwareversion(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
@@ -4137,7 +4222,7 @@ bool isvalidip(char *ipaddr)
 
 bool isvalidport(int portnum)
 {
-     return (portnum > 0 && portnum < 65536);
+    return (portnum > 0 && portnum < 65536);
 }
 
 bool isvalidimagename(char *imagename)
@@ -4160,11 +4245,11 @@ bool upgradelinux(char *serverip, char *serverport, char *image)
     return upgraderet;
 }
 
-int
+    int
 handle_upgradingstart(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     char serverip[16], serverport[16], imagename[32];
@@ -4173,21 +4258,21 @@ handle_upgradingstart(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPFALSE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4216,7 +4301,7 @@ handle_upgradingstart(netsnmp_mib_handler *handler,
             strcpy(serverport, nvram_safe_get("upgradeserverport"));
             strcpy(imagename, nvram_safe_get("upgradefilename"));
 
-            
+
             if (isvalidip(serverip) && isvalidport(atoi(serverport)) \
                     && isvalidimagename(imagename)) {
                 upgradelinux(serverip, serverport, imagename);
@@ -4253,11 +4338,11 @@ handle_upgradingstart(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_rebootafterupgrading(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -4265,22 +4350,22 @@ handle_rebootafterupgrading(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
-                                     rebootonceupgradedone);
+                    rebootonceupgradedone);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4302,7 +4387,7 @@ handle_rebootafterupgrading(netsnmp_mib_handler *handler,
 
         case MODE_SET_ACTION:
             if ((*requests->requestvb->val.integer == SNMPTRUE) ||
-            (*requests->requestvb->val.integer == SNMPFALSE)) {
+                    (*requests->requestvb->val.integer == SNMPFALSE)) {
                 rebootonceupgradedone = *requests->requestvb->val.integer;
             }
             else
@@ -4335,11 +4420,11 @@ handle_rebootafterupgrading(netsnmp_mib_handler *handler,
 }
 
 //new nvram:upgradefilename
-int
+    int
 handle_imagefilename(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret,length;
     char *pval;
@@ -4348,7 +4433,7 @@ handle_imagefilename(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -4358,14 +4443,14 @@ handle_imagefilename(netsnmp_mib_handler *handler,
                     pval, length);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4387,7 +4472,7 @@ handle_imagefilename(netsnmp_mib_handler *handler,
 
         case MODE_SET_ACTION:
             nvram_nset("upgradefilename", requests->requestvb->val.string, \
-                        requests->requestvb->val_len);
+                    requests->requestvb->val_len);
             break;
 
         case MODE_SET_COMMIT:
@@ -4416,11 +4501,11 @@ handle_imagefilename(netsnmp_mib_handler *handler,
 }
 
 //new nvram:upgradeserverip
-int
+    int
 handle_serverip(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     struct in_addr addr;
@@ -4430,7 +4515,7 @@ handle_serverip(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -4448,14 +4533,14 @@ handle_serverip(netsnmp_mib_handler *handler,
             }
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4512,11 +4597,11 @@ handle_serverip(netsnmp_mib_handler *handler,
 }
 
 //new nvram:upgradeserverport
-int
+    int
 handle_serverport(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret, serverport;
     char *pval;
@@ -4526,7 +4611,7 @@ handle_serverport(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
@@ -4540,14 +4625,14 @@ handle_serverport(netsnmp_mib_handler *handler,
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, serverport);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4604,11 +4689,11 @@ handle_serverport(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_vlanenabled(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -4616,21 +4701,21 @@ handle_vlanenabled(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, SNMPTRUE);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4679,11 +4764,11 @@ handle_vlanenabled(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_bridgedvlanid(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -4691,21 +4776,21 @@ handle_bridgedvlanid(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,BRIDGEDVID);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4754,11 +4839,11 @@ handle_bridgedvlanid(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-int
+    int
 handle_natvlanid(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
+        netsnmp_handler_registration *reginfo,
+        netsnmp_agent_request_info   *reqinfo,
+        netsnmp_request_info         *requests)
 {
     int ret;
     /* We are never called for a GETNEXT if it's registered as a
@@ -4766,21 +4851,21 @@ handle_natvlanid(netsnmp_mib_handler *handler,
 
     /* a instance handler also only hands us one request at a time, so
        we don't need to loop over a list of requests; we'll only get one. */
-    
+
     switch(reqinfo->mode) {
 
         case MODE_GET:
             snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,NATEDVID);
             break;
 
-        /*
-         * SET REQUEST
-         *
-         * multiple states in the transaction.  See:
-         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
-         */
+            /*
+             * SET REQUEST
+             *
+             * multiple states in the transaction.  See:
+             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+             */
         case MODE_SET_RESERVE1:
-                /* or you could use netsnmp_check_vb_type_and_size instead */
+            /* or you could use netsnmp_check_vb_type_and_size instead */
             ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
             if ( ret != SNMP_ERR_NOERROR ) {
                 netsnmp_set_request_error(reqinfo, requests, ret );
@@ -4830,7 +4915,7 @@ handle_natvlanid(netsnmp_mib_handler *handler,
 }
 
 /** Initialize the wirelessTable table by defining its contents and how it's structured */
-void
+    void
 initialize_table_wirelessTable(void)
 {
     const oid wirelessTable_oid[] = {1,3,6,1,4,1,46227,2,3,1,1,9};
@@ -4842,23 +4927,23 @@ initialize_table_wirelessTable(void)
     DEBUGMSGTL(("gxgdWiFiModule_table:init", "initializing table wirelessTable\n"));
 
     reg = netsnmp_create_handler_registration(
-              "wirelessTable",     wirelessTable_handler,
-              wirelessTable_oid, wirelessTable_oid_len,
-              HANDLER_CAN_RWRITE
-              );
+            "wirelessTable",     wirelessTable_handler,
+            wirelessTable_oid, wirelessTable_oid_len,
+            HANDLER_CAN_RWRITE
+            );
 
     table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
     netsnmp_table_helper_add_indexes(table_info,
-                           ASN_INTEGER,  /* index: ssidindex */
-                           0);
+            ASN_INTEGER,  /* index: ssidindex */
+            0);
     table_info->min_column = COLUMN_SSIDTAILER;
     table_info->max_column = COLUMN_SSIDINDEX;
-    
+
     iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
     iinfo->get_first_data_point = wirelessTable_get_first_data_point;
     iinfo->get_next_data_point  = wirelessTable_get_next_data_point;
     iinfo->table_reginfo        = table_info;
-    
+
     netsnmp_register_table_iterator( reg, iinfo );
 
     /* Initialise the contents of the table here */
@@ -4889,8 +4974,8 @@ wirelessTable_removeEntry( struct wirelessTable_entry *entry ) {
         return;    /* Nothing to remove */
 
     for ( ptr  = wirelessTable_head, prev = NULL;
-          ptr != NULL;
-          prev = ptr, ptr = ptr->next ) {
+            ptr != NULL;
+            prev = ptr, ptr = ptr->next ) {
         if ( ptr == entry )
             break;
     }
@@ -4907,23 +4992,23 @@ wirelessTable_removeEntry( struct wirelessTable_entry *entry ) {
 
 
 /* Example iterator hook routines - using 'get_next' to do most of the work */
-netsnmp_variable_list *
+    netsnmp_variable_list *
 wirelessTable_get_first_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     buildwfitable();
     *my_loop_context = wirelessTable_head;
     return wirelessTable_get_next_data_point(my_loop_context, my_data_context,
-                                    put_index_data,  mydata );
+            put_index_data,  mydata );
 }
 
-netsnmp_variable_list *
+    netsnmp_variable_list *
 wirelessTable_get_next_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     struct wirelessTable_entry *entry = (struct wirelessTable_entry *)*my_loop_context;
     netsnmp_variable_list *idx = put_index_data;
@@ -4943,10 +5028,10 @@ wirelessTable_get_next_data_point(void **my_loop_context,
 /** handles requests for the wirelessTable table */
 int
 wirelessTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
+        netsnmp_mib_handler               *handler,
+        netsnmp_handler_registration      *reginfo,
+        netsnmp_agent_request_info        *reqinfo,
+        netsnmp_request_info              *requests) {
 
     netsnmp_request_info       *request;
     netsnmp_table_request_info *table_info;
@@ -4961,540 +5046,540 @@ wirelessTable_handler(
         /*
          * Read-support (also covers GetNext requests)
          */
-    case MODE_GET:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct wirelessTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_SSIDTAILER:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->ssidtailer,
-                                          table_entry->ssidtailer_len);
-                break;
-            case COLUMN_ISOLATION:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->isolation);
-                break;
-            case COLUMN_SSIDBROADCAST:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->ssidbroadcast);
-                break;
-            case COLUMN_SECMODE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->secmode);
-                break;
-            case COLUMN_PASSPHRASE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->passphrase,
-                                          table_entry->passphrase_len);
-                break;
-            case COLUMN_MAXSTA:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->maxsta);
-                break;
-            case COLUMN_ENCRYPTIONMETHOD:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->encryptionmethod);
-                break;
-            case COLUMN_ENABLED:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->enabled);
-                break;
-            case COLUMN_MACADDRESS:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->macaddress,
-                                          table_entry->macaddress_len);
-                break;
-            case COLUMN_HEADERCHANGABLE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->headerchangable);
-                break;
-            case COLUMN_SSIDHEADER:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->ssidheader,
-                                          table_entry->ssidheader_len);
-                break;
-            case COLUMN_SSIDINDEX:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
+        case MODE_GET:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct wirelessTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_SSIDTAILER:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->ssidtailer,
+                                table_entry->ssidtailer_len);
+                        break;
+                    case COLUMN_ISOLATION:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->isolation);
+                        break;
+                    case COLUMN_SSIDBROADCAST:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->ssidbroadcast);
+                        break;
+                    case COLUMN_SECMODE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->secmode);
+                        break;
+                    case COLUMN_PASSPHRASE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->passphrase,
+                                table_entry->passphrase_len);
+                        break;
+                    case COLUMN_MAXSTA:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->maxsta);
+                        break;
+                    case COLUMN_ENCRYPTIONMETHOD:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->encryptionmethod);
+                        break;
+                    case COLUMN_ENABLED:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->enabled);
+                        break;
+                    case COLUMN_MACADDRESS:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->macaddress,
+                                table_entry->macaddress_len);
+                        break;
+                    case COLUMN_HEADERCHANGABLE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->headerchangable);
+                        break;
+                    case COLUMN_SSIDHEADER:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->ssidheader,
+                                table_entry->ssidheader_len);
+                        break;
+                    case COLUMN_SSIDINDEX:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->ssidindex);
+                        break;
+                    default:
+                        netsnmp_set_request_error(reqinfo, request,
+                                SNMP_NOSUCHOBJECT);
+                        break;
                 }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->ssidindex);
-                break;
-            default:
-                netsnmp_set_request_error(reqinfo, request,
-                                          SNMP_NOSUCHOBJECT);
-                break;
             }
-        }
-        break;
+            break;
 
-        /*
-         * Write-support
-         */
-    case MODE_SET_RESERVE1:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct wirelessTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_SSIDTAILER:
-	        /* or possibly 'netsnmp_check_vb_type_and_size' */
-                ret = netsnmp_check_vb_type_and_max_size(
-                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ssidtailer));
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_ISOLATION:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_SSIDBROADCAST:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_SECMODE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_PASSPHRASE:
-	        /* or possibly 'netsnmp_check_vb_type_and_size' */
-                ret = netsnmp_check_vb_type_and_max_size(
-                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->passphrase));
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_MAXSTA:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_ENCRYPTIONMETHOD:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_ENABLED:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_MACADDRESS:
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                break;
-            case COLUMN_HEADERCHANGABLE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                if(wlifindex != 0){
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                }
-                else{
-                    ret = netsnmp_check_vb_int( request->requestvb );
-                    if ( ret != SNMP_ERR_NOERROR ) {
-                        netsnmp_set_request_error( reqinfo, request, ret );
-                        return SNMP_ERR_NOERROR;
-                    }
-                }
-                break;
-            case COLUMN_SSIDHEADER:
-	        /* or possibly 'netsnmp_check_vb_type_and_size' */
-                if(wlifindex == 0){
-                    ret = netsnmp_check_vb_type_and_max_size(
-                            request->requestvb, ASN_OCTET_STR, MAXSSIDHDRLEN-1);
-                    if ( ret != SNMP_ERR_NOERROR ) {
-                        netsnmp_set_request_error( reqinfo, request, ret );
+            /*
+             * Write-support
+             */
+        case MODE_SET_RESERVE1:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct wirelessTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_SSIDTAILER:
+                        /* or possibly 'netsnmp_check_vb_type_and_size' */
+                        ret = netsnmp_check_vb_type_and_max_size(
+                                request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ssidtailer));
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_ISOLATION:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_SSIDBROADCAST:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_SECMODE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_PASSPHRASE:
+                        /* or possibly 'netsnmp_check_vb_type_and_size' */
+                        ret = netsnmp_check_vb_type_and_max_size(
+                                request->requestvb, ASN_OCTET_STR, sizeof(table_entry->passphrase));
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_MAXSTA:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_ENCRYPTIONMETHOD:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_ENABLED:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_MACADDRESS:
+                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        break;
+                    case COLUMN_HEADERCHANGABLE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        if(wlifindex != 0){
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        }
+                        else{
+                            ret = netsnmp_check_vb_int( request->requestvb );
+                            if ( ret != SNMP_ERR_NOERROR ) {
+                                netsnmp_set_request_error( reqinfo, request, ret );
+                                return SNMP_ERR_NOERROR;
+                            }
+                        }
+                        break;
+                    case COLUMN_SSIDHEADER:
+                        /* or possibly 'netsnmp_check_vb_type_and_size' */
+                        if(wlifindex == 0){
+                            ret = netsnmp_check_vb_type_and_max_size(
+                                    request->requestvb, ASN_OCTET_STR, MAXSSIDHDRLEN-1);
+                            if ( ret != SNMP_ERR_NOERROR ) {
+                                netsnmp_set_request_error( reqinfo, request, ret );
+                                return SNMP_ERR_NOERROR;
+                            }
+                        }
+                        else{
+                            netsnmp_set_request_error( reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        }
+                        break;
+                    case COLUMN_SSIDINDEX:
+                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        /*ret = netsnmp_check_vb_int( request->requestvb );
+                          if ( ret != SNMP_ERR_NOERROR ) {
+                          netsnmp_set_request_error( reqinfo, request, ret );
+                          return SNMP_ERR_NOERROR;
+                          }*/
+                        break;
+                    default:
+                        netsnmp_set_request_error( reqinfo, request,
+                                SNMP_ERR_NOTWRITABLE );
                         return SNMP_ERR_NOERROR;
-                    }
                 }
-                else{
-                    netsnmp_set_request_error( reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                }
-                break;
-            case COLUMN_SSIDINDEX:
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                /*ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }*/
-                break;
-            default:
-                netsnmp_set_request_error( reqinfo, request,
-                                           SNMP_ERR_NOTWRITABLE );
-                return SNMP_ERR_NOERROR;
             }
-        }
-        break;
-
-    case MODE_SET_RESERVE2:
-        break;
-
-    case MODE_SET_FREE:
-        break;
-
-    case MODE_SET_ACTION:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct wirelessTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
+            break;
 
-            bzero(nvname, sizeof(nvname));
-            bzero(tmpbuf, sizeof(tmpbuf));
-            bzero(wlnameprefix, sizeof(wlnameprefix));
+        case MODE_SET_RESERVE2:
+            break;
 
-            wlifindex = table_entry->ssidindex;
+        case MODE_SET_FREE:
+            break;
 
-            if(wlifindex == 0){
-                strcpy(wlnameprefix, "wl0");
-            }
-            else{
-                sprintf(wlnameprefix, "wl0.%d", wlifindex);
-            }
-    
-            switch (table_info->colnum) {
-            case COLUMN_SSIDTAILER:
-                memcpy( table_entry->old_ssidtailer,
-                        table_entry->ssidtailer,
-                        sizeof(table_entry->ssidtailer));
-                table_entry->old_ssidtailer_len =
-                        table_entry->ssidtailer_len;
-                memset( table_entry->ssidtailer, 0,
-                        sizeof(table_entry->ssidtailer));
-                memcpy( table_entry->ssidtailer,
-                        request->requestvb->val.string,
-                        request->requestvb->val_len);
-                table_entry->ssidtailer_len =
-                        request->requestvb->val_len;
-
-                sprintf(nvname, "%s_ssidheader", wlnameprefix);
-                strncpy(tmpbuf, nvram_safe_get(nvname), sizeof(tmpbuf));
-                strncat(tmpbuf,table_entry->ssidtailer,table_entry->ssidtailer_len);
+        case MODE_SET_ACTION:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct wirelessTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
 
                 bzero(nvname, sizeof(nvname));
-                sprintf(nvname, "%s_ssid", wlnameprefix);
-                nvram_set(nvname, tmpbuf);
-                break;
-
-            case COLUMN_ISOLATION:
-                table_entry->old_isolation = table_entry->isolation;
-                table_entry->isolation     = *request->requestvb->val.integer;
-
-                sprintf(nvname, "%s_ap_isolate", wlnameprefix);
-                if(table_entry->isolation == SNMPFALSE)
-                   nvram_set(nvname, "0");
-                else if(table_entry->isolation == SNMPTRUE)
-                   nvram_set(nvname, "1");
-                else
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                break;
-
-            case COLUMN_SSIDBROADCAST:
-                table_entry->old_ssidbroadcast = table_entry->ssidbroadcast;
-                table_entry->ssidbroadcast     = *request->requestvb->val.integer;
-                
-                sprintf(nvname, "%s_closed", wlnameprefix);
-                if(table_entry->ssidbroadcast == SNMPFALSE)
-                   nvram_set(nvname, "1");
-                else if(table_entry->ssidbroadcast == SNMPTRUE)
-                   nvram_set(nvname, "0");
-                else
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                break;
-
-            case COLUMN_SECMODE:
-                table_entry->old_secmode = table_entry->secmode;
-                table_entry->secmode     = *request->requestvb->val.integer;
-                if(!setwlsecuritymode(table_entry->secmode, wlnameprefix, table_entry))
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                break;
-
-            case COLUMN_PASSPHRASE:
-                memcpy( table_entry->old_passphrase,
-                        table_entry->passphrase,
-                        sizeof(table_entry->passphrase));
-                table_entry->old_passphrase_len =
-                        table_entry->passphrase_len;
-                memset( table_entry->passphrase, 0,
-                        sizeof(table_entry->passphrase));
-                memcpy( table_entry->passphrase,
-                        request->requestvb->val.string,
-                        request->requestvb->val_len);
-                table_entry->passphrase_len =
-                        request->requestvb->val_len;
-                
-                sprintf(nvname, "%s_wpa_psk", wlnameprefix);
-                nvram_set(nvname, table_entry->passphrase);
-                break;
-
-            case COLUMN_MAXSTA:
-                table_entry->old_maxsta = table_entry->maxsta;
-                table_entry->maxsta     = *request->requestvb->val.integer;
-                
-                sprintf(nvname, "%s_maxassoc", wlnameprefix);
-                if(table_entry->maxsta <= 128 && table_entry->maxsta >= 0){
-                    snprintf(tmpbuf, sizeof(tmpbuf), "%d", table_entry->maxsta);
-                    nvram_set(nvname,tmpbuf);
-                }
-                else{
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                }
-                break;
-
-            case COLUMN_ENCRYPTIONMETHOD:
-                table_entry->old_encryptionmethod = table_entry->encryptionmethod;
-                table_entry->encryptionmethod     = *request->requestvb->val.integer;
-
-                if(table_entry->encryptionmethod == ENCRY_TKIP \
-                        || table_entry->encryptionmethod == ENCRY_AES \
-                        || table_entry->encryptionmethod == ENCRY_TKIPAES)
-                    setwlencryptionmethod(table_entry->encryptionmethod, wlnameprefix, table_entry);
-                else
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                break;
-
-            case COLUMN_ENABLED:
-                table_entry->old_enabled = table_entry->enabled;
-                table_entry->enabled     = *request->requestvb->val.integer;
-
-                sprintf(nvname, "%s_bss_enabled", wlnameprefix);
-                if(table_entry->enabled == SNMPTRUE){
-                    nvram_set(nvname, "1");
-                }
-                else if(table_entry->enabled == SNMPFALSE){
-                    nvram_set(nvname, "0");
-                }
-                else{
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
-                }
-                break;
+                bzero(tmpbuf, sizeof(tmpbuf));
+                bzero(wlnameprefix, sizeof(wlnameprefix));
 
-            case COLUMN_MACADDRESS:
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                break;
+                wlifindex = table_entry->ssidindex;
 
-            case COLUMN_HEADERCHANGABLE:
                 if(wlifindex == 0){
-                    table_entry->old_headerchangable = table_entry->headerchangable;
-                    table_entry->headerchangable     = *request->requestvb->val.integer;
-
-                    if(table_entry->headerchangable == SNMPTRUE)
-                        nvram_set("wl0_ssidheader_changable", "1");
-                    else if(table_entry->headerchangable == SNMPFALSE)
-                        nvram_set("wl0_ssidheader_changable", "0");
-                    else
-                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                    strcpy(wlnameprefix, "wl0");
                 }
                 else{
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                    sprintf(wlnameprefix, "wl0.%d", wlifindex);
                 }
-                break;
 
-            case COLUMN_SSIDHEADER:
-                if(nvram_invmatch("wl0_ssidheader_changable", "1"))
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                else{
-                    if(wlifindex == 0){
-                        memcpy( table_entry->old_ssidheader,
-                                table_entry->ssidheader,
-                                sizeof(table_entry->ssidheader));
-                        table_entry->old_ssidheader_len =
-                            table_entry->ssidheader_len;
-                        memset( table_entry->ssidheader, 0,
-                                sizeof(table_entry->ssidheader));
-                        memcpy( table_entry->ssidheader,
+                switch (table_info->colnum) {
+                    case COLUMN_SSIDTAILER:
+                        memcpy( table_entry->old_ssidtailer,
+                                table_entry->ssidtailer,
+                                sizeof(table_entry->ssidtailer));
+                        table_entry->old_ssidtailer_len =
+                            table_entry->ssidtailer_len;
+                        memset( table_entry->ssidtailer, 0,
+                                sizeof(table_entry->ssidtailer));
+                        memcpy( table_entry->ssidtailer,
+                                request->requestvb->val.string,
+                                request->requestvb->val_len);
+                        table_entry->ssidtailer_len =
+                            request->requestvb->val_len;
+
+                        sprintf(nvname, "%s_ssidheader", wlnameprefix);
+                        strncpy(tmpbuf, nvram_safe_get(nvname), sizeof(tmpbuf));
+                        strncat(tmpbuf,table_entry->ssidtailer,table_entry->ssidtailer_len);
+
+                        bzero(nvname, sizeof(nvname));
+                        sprintf(nvname, "%s_ssid", wlnameprefix);
+                        nvram_set(nvname, tmpbuf);
+                        break;
+
+                    case COLUMN_ISOLATION:
+                        table_entry->old_isolation = table_entry->isolation;
+                        table_entry->isolation     = *request->requestvb->val.integer;
+
+                        sprintf(nvname, "%s_ap_isolate", wlnameprefix);
+                        if(table_entry->isolation == SNMPFALSE)
+                            nvram_set(nvname, "0");
+                        else if(table_entry->isolation == SNMPTRUE)
+                            nvram_set(nvname, "1");
+                        else
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        break;
+
+                    case COLUMN_SSIDBROADCAST:
+                        table_entry->old_ssidbroadcast = table_entry->ssidbroadcast;
+                        table_entry->ssidbroadcast     = *request->requestvb->val.integer;
+
+                        sprintf(nvname, "%s_closed", wlnameprefix);
+                        if(table_entry->ssidbroadcast == SNMPFALSE)
+                            nvram_set(nvname, "1");
+                        else if(table_entry->ssidbroadcast == SNMPTRUE)
+                            nvram_set(nvname, "0");
+                        else
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        break;
+
+                    case COLUMN_SECMODE:
+                        table_entry->old_secmode = table_entry->secmode;
+                        table_entry->secmode     = *request->requestvb->val.integer;
+                        if(!setwlsecuritymode(table_entry->secmode, wlnameprefix, table_entry))
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        break;
+
+                    case COLUMN_PASSPHRASE:
+                        memcpy( table_entry->old_passphrase,
+                                table_entry->passphrase,
+                                sizeof(table_entry->passphrase));
+                        table_entry->old_passphrase_len =
+                            table_entry->passphrase_len;
+                        memset( table_entry->passphrase, 0,
+                                sizeof(table_entry->passphrase));
+                        memcpy( table_entry->passphrase,
                                 request->requestvb->val.string,
                                 request->requestvb->val_len);
-                        table_entry->ssidheader_len =
+                        table_entry->passphrase_len =
                             request->requestvb->val_len;
 
-                        nvram_set("wl0_ssidheader", table_entry->ssidheader);
-                    }
-                    else{
+                        sprintf(nvname, "%s_wpa_psk", wlnameprefix);
+                        nvram_set(nvname, table_entry->passphrase);
+                        break;
+
+                    case COLUMN_MAXSTA:
+                        table_entry->old_maxsta = table_entry->maxsta;
+                        table_entry->maxsta     = *request->requestvb->val.integer;
+
+                        sprintf(nvname, "%s_maxassoc", wlnameprefix);
+                        if(table_entry->maxsta <= 128 && table_entry->maxsta >= 0){
+                            snprintf(tmpbuf, sizeof(tmpbuf), "%d", table_entry->maxsta);
+                            nvram_set(nvname,tmpbuf);
+                        }
+                        else{
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        }
+                        break;
+
+                    case COLUMN_ENCRYPTIONMETHOD:
+                        table_entry->old_encryptionmethod = table_entry->encryptionmethod;
+                        table_entry->encryptionmethod     = *request->requestvb->val.integer;
+
+                        if(table_entry->encryptionmethod == ENCRY_TKIP \
+                                || table_entry->encryptionmethod == ENCRY_AES \
+                                || table_entry->encryptionmethod == ENCRY_TKIPAES)
+                            setwlencryptionmethod(table_entry->encryptionmethod, wlnameprefix, table_entry);
+                        else
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        break;
+
+                    case COLUMN_ENABLED:
+                        table_entry->old_enabled = table_entry->enabled;
+                        table_entry->enabled     = *request->requestvb->val.integer;
+
+                        sprintf(nvname, "%s_bss_enabled", wlnameprefix);
+                        if(table_entry->enabled == SNMPTRUE){
+                            nvram_set(nvname, "1");
+                        }
+                        else if(table_entry->enabled == SNMPFALSE){
+                            nvram_set(nvname, "0");
+                        }
+                        else{
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        }
+                        break;
+
+                    case COLUMN_MACADDRESS:
+                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        break;
+
+                    case COLUMN_HEADERCHANGABLE:
+                        if(wlifindex == 0){
+                            table_entry->old_headerchangable = table_entry->headerchangable;
+                            table_entry->headerchangable     = *request->requestvb->val.integer;
+
+                            if(table_entry->headerchangable == SNMPTRUE)
+                                nvram_set("wl0_ssidheader_changable", "1");
+                            else if(table_entry->headerchangable == SNMPFALSE)
+                                nvram_set("wl0_ssidheader_changable", "0");
+                            else
+                                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_BADVALUE);
+                        }
+                        else{
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        }
+                        break;
+
+                    case COLUMN_SSIDHEADER:
+                        if(nvram_invmatch("wl0_ssidheader_changable", "1"))
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        else{
+                            if(wlifindex == 0){
+                                memcpy( table_entry->old_ssidheader,
+                                        table_entry->ssidheader,
+                                        sizeof(table_entry->ssidheader));
+                                table_entry->old_ssidheader_len =
+                                    table_entry->ssidheader_len;
+                                memset( table_entry->ssidheader, 0,
+                                        sizeof(table_entry->ssidheader));
+                                memcpy( table_entry->ssidheader,
+                                        request->requestvb->val.string,
+                                        request->requestvb->val_len);
+                                table_entry->ssidheader_len =
+                                    request->requestvb->val_len;
+
+                                nvram_set("wl0_ssidheader", table_entry->ssidheader);
+                            }
+                            else{
+                                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                            }
+                        }
+                        break;
+
+                    case COLUMN_SSIDINDEX:
+                        //table_entry->old_ssidindex = table_entry->ssidindex;
+                        //table_entry->ssidindex     = *request->requestvb->val.integer;
                         netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                    }
+                        break;
                 }
-                break;
-
-            case COLUMN_SSIDINDEX:
-                //table_entry->old_ssidindex = table_entry->ssidindex;
-                //table_entry->ssidindex     = *request->requestvb->val.integer;
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                break;
             }
-        }
-        break;
-
-    case MODE_SET_UNDO:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct wirelessTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_SSIDTAILER:
-                memcpy( table_entry->ssidtailer,
-                        table_entry->old_ssidtailer,
-                        sizeof(table_entry->ssidtailer));
-                memset( table_entry->old_ssidtailer, 0,
-                        sizeof(table_entry->ssidtailer));
-                table_entry->ssidtailer_len =
-                        table_entry->old_ssidtailer_len;
-                break;
-            case COLUMN_ISOLATION:
-                table_entry->isolation     = table_entry->old_isolation;
-                table_entry->old_isolation = 0;
-                break;
-            case COLUMN_SSIDBROADCAST:
-                table_entry->ssidbroadcast     = table_entry->old_ssidbroadcast;
-                table_entry->old_ssidbroadcast = 0;
-                break;
-            case COLUMN_SECMODE:
-                table_entry->secmode     = table_entry->old_secmode;
-                table_entry->old_secmode = 0;
-                break;
-            case COLUMN_PASSPHRASE:
-                memcpy( table_entry->passphrase,
-                        table_entry->old_passphrase,
-                        sizeof(table_entry->passphrase));
-                memset( table_entry->old_passphrase, 0,
-                        sizeof(table_entry->passphrase));
-                table_entry->passphrase_len =
-                        table_entry->old_passphrase_len;
-                break;
-            case COLUMN_MAXSTA:
-                table_entry->maxsta     = table_entry->old_maxsta;
-                table_entry->old_maxsta = 0;
-                break;
-            case COLUMN_ENCRYPTIONMETHOD:
-                table_entry->encryptionmethod     = table_entry->old_encryptionmethod;
-                table_entry->old_encryptionmethod = 0;
-                break;
-            case COLUMN_ENABLED:
-                table_entry->enabled     = table_entry->old_enabled;
-                table_entry->old_enabled = 0;
-                break;
-            case COLUMN_MACADDRESS:
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                break;
-            case COLUMN_HEADERCHANGABLE:
-                if(wlifindex != 0){
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                }
-                else{
-                    table_entry->headerchangable     = table_entry->old_headerchangable;
-                    table_entry->old_headerchangable = 0;
-                }
-                break;
-            case COLUMN_SSIDHEADER:
-                if(wlifindex == 0){
-                    memcpy( table_entry->ssidheader,
-                            table_entry->old_ssidheader,
-                            sizeof(table_entry->ssidheader));
-                    memset( table_entry->old_ssidheader, 0,
-                            sizeof(table_entry->ssidheader));
-                    table_entry->ssidheader_len =
-                        table_entry->old_ssidheader_len;
-                }
-                else{
-                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+            break;
+
+        case MODE_SET_UNDO:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct wirelessTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_SSIDTAILER:
+                        memcpy( table_entry->ssidtailer,
+                                table_entry->old_ssidtailer,
+                                sizeof(table_entry->ssidtailer));
+                        memset( table_entry->old_ssidtailer, 0,
+                                sizeof(table_entry->ssidtailer));
+                        table_entry->ssidtailer_len =
+                            table_entry->old_ssidtailer_len;
+                        break;
+                    case COLUMN_ISOLATION:
+                        table_entry->isolation     = table_entry->old_isolation;
+                        table_entry->old_isolation = 0;
+                        break;
+                    case COLUMN_SSIDBROADCAST:
+                        table_entry->ssidbroadcast     = table_entry->old_ssidbroadcast;
+                        table_entry->old_ssidbroadcast = 0;
+                        break;
+                    case COLUMN_SECMODE:
+                        table_entry->secmode     = table_entry->old_secmode;
+                        table_entry->old_secmode = 0;
+                        break;
+                    case COLUMN_PASSPHRASE:
+                        memcpy( table_entry->passphrase,
+                                table_entry->old_passphrase,
+                                sizeof(table_entry->passphrase));
+                        memset( table_entry->old_passphrase, 0,
+                                sizeof(table_entry->passphrase));
+                        table_entry->passphrase_len =
+                            table_entry->old_passphrase_len;
+                        break;
+                    case COLUMN_MAXSTA:
+                        table_entry->maxsta     = table_entry->old_maxsta;
+                        table_entry->old_maxsta = 0;
+                        break;
+                    case COLUMN_ENCRYPTIONMETHOD:
+                        table_entry->encryptionmethod     = table_entry->old_encryptionmethod;
+                        table_entry->old_encryptionmethod = 0;
+                        break;
+                    case COLUMN_ENABLED:
+                        table_entry->enabled     = table_entry->old_enabled;
+                        table_entry->old_enabled = 0;
+                        break;
+                    case COLUMN_MACADDRESS:
+                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        break;
+                    case COLUMN_HEADERCHANGABLE:
+                        if(wlifindex != 0){
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        }
+                        else{
+                            table_entry->headerchangable     = table_entry->old_headerchangable;
+                            table_entry->old_headerchangable = 0;
+                        }
+                        break;
+                    case COLUMN_SSIDHEADER:
+                        if(wlifindex == 0){
+                            memcpy( table_entry->ssidheader,
+                                    table_entry->old_ssidheader,
+                                    sizeof(table_entry->ssidheader));
+                            memset( table_entry->old_ssidheader, 0,
+                                    sizeof(table_entry->ssidheader));
+                            table_entry->ssidheader_len =
+                                table_entry->old_ssidheader_len;
+                        }
+                        else{
+                            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        }
+                        break;
+                    case COLUMN_SSIDINDEX:
+                        //table_entry->ssidindex     = table_entry->old_ssidindex;
+                        //table_entry->old_ssidindex = 0;
+                        netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
+                        break;
                 }
-                break;
-            case COLUMN_SSIDINDEX:
-                //table_entry->ssidindex     = table_entry->old_ssidindex;
-                //table_entry->old_ssidindex = 0;
-                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
-                break;
             }
-        }
-        break;
+            break;
 
-    case MODE_SET_COMMIT:
-        break;
+        case MODE_SET_COMMIT:
+            break;
     }
     return SNMP_ERR_NOERROR;
 }
@@ -5570,7 +5655,7 @@ bool setwlencryptionmethod(int encryptmode, char *wlnameprefix, struct wirelessT
     }
 
     getwlsecmethod(&secmode, wlnameprefix);
-    
+
     if(secmode != KEYMGMT_WPAPSK && secmode != KEYMGMT_WPA2PSK \
             && secmode != KEYMGMT_PSKMIXED){
         bzero(nvname, sizeof(nvname));
@@ -5703,7 +5788,7 @@ int buildwfitable(void)
         strcpy(tmp, nvram_safe_get(nvname));
         entry->maxsta = atoi(tmp);
 
-        
+
         bzero(nvname, sizeof(nvname));
         bzero(tmp, sizeof(tmp));
         sprintf(nvname, "%s_crypto", wlnameprefix);
@@ -5747,7 +5832,7 @@ int buildwfitable(void)
 }
 
 /** Initialize the dhcpclientTable table by defining its contents and how it's structured */
-void
+    void
 initialize_table_dhcpclientTable(void)
 {
     const oid dhcpclientTable_oid[] = {1,3,6,1,4,1,46227,2,7,1};
@@ -5759,30 +5844,30 @@ initialize_table_dhcpclientTable(void)
     DEBUGMSGTL(("gxgdWiFiModule_table:init", "initializing table dhcpclientTable\n"));
 
     reg = netsnmp_create_handler_registration(
-              "dhcpclientTable",     dhcpclientTable_handler,
-              dhcpclientTable_oid, dhcpclientTable_oid_len,
-              HANDLER_CAN_RONLY
-              );
+            "dhcpclientTable",     dhcpclientTable_handler,
+            dhcpclientTable_oid, dhcpclientTable_oid_len,
+            HANDLER_CAN_RONLY
+            );
 
     table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
     netsnmp_table_helper_add_indexes(table_info,
-                           ASN_INTEGER,  /* index: clientindex */
-                           0);
+            ASN_INTEGER,  /* index: clientindex */
+            0);
     table_info->min_column = COLUMN_CLIENTINDEX;
     table_info->max_column = COLUMN_CLIENTLEASETIME;
-    
+
     iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
     iinfo->get_first_data_point = dhcpclientTable_get_first_data_point;
     iinfo->get_next_data_point  = dhcpclientTable_get_next_data_point;
     iinfo->table_reginfo        = table_info;
-    
+
     netsnmp_register_table_iterator( reg, iinfo );
 
     /* Initialise the contents of the table here */
     buildhcpclienttable();
 }
 
-    /* Typical data structure for a row entry */
+/* Typical data structure for a row entry */
 struct dhcpclientTable_entry {
     /* Index values */
     long clientindex;
@@ -5824,8 +5909,8 @@ dhcpclientTable_removeEntry( struct dhcpclientTable_entry *entry ) {
         return;    /* Nothing to remove */
 
     for ( ptr  = dhcpclientTable_head, prev = NULL;
-          ptr != NULL;
-          prev = ptr, ptr = ptr->next ) {
+            ptr != NULL;
+            prev = ptr, ptr = ptr->next ) {
         if ( ptr == entry )
             break;
     }
@@ -5842,23 +5927,23 @@ dhcpclientTable_removeEntry( struct dhcpclientTable_entry *entry ) {
 
 
 /* Example iterator hook routines - using 'get_next' to do most of the work */
-netsnmp_variable_list *
+    netsnmp_variable_list *
 dhcpclientTable_get_first_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     buildhcpclienttable();
     *my_loop_context = dhcpclientTable_head;
     return dhcpclientTable_get_next_data_point(my_loop_context, my_data_context,
-                                    put_index_data,  mydata );
+            put_index_data,  mydata );
 }
 
-netsnmp_variable_list *
+    netsnmp_variable_list *
 dhcpclientTable_get_next_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     struct dhcpclientTable_entry *entry = (struct dhcpclientTable_entry *)*my_loop_context;
     netsnmp_variable_list *idx = put_index_data;
@@ -5874,17 +5959,17 @@ dhcpclientTable_get_next_data_point(void **my_loop_context,
     }
 }
 
-static char *
+    static char *
 reltime_short(unsigned int seconds)
 {
-	static char buf[16];
+    static char buf[16];
 
-	sprintf(buf, "%02d:%02d:%02d",
-	        seconds / 3600,
-	        (seconds % 3600) / 60,
-	        seconds % 60);
+    sprintf(buf, "%02d:%02d:%02d",
+            seconds / 3600,
+            (seconds % 3600) / 60,
+            seconds % 60);
 
-	return buf;
+    return buf;
 }
 
 void buildhcpclienttable()
@@ -5940,10 +6025,10 @@ void buildhcpclienttable()
 /** handles requests for the dhcpclientTable table */
 int
 dhcpclientTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
+        netsnmp_mib_handler               *handler,
+        netsnmp_handler_registration      *reginfo,
+        netsnmp_agent_request_info        *reqinfo,
+        netsnmp_request_info              *requests) {
 
     netsnmp_request_info       *request;
     netsnmp_table_request_info *table_info;
@@ -5955,64 +6040,64 @@ dhcpclientTable_handler(
         /*
          * Read-support (also covers GetNext requests)
          */
-    case MODE_GET:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct dhcpclientTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_CLIENTINDEX:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->clientindex);
-                break;
-            case COLUMN_CLIENTMAC:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->clientmac,
-                                          MACADDRSTRLEN);
-                break;
-            case COLUMN_CLIENTIP:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
-                                            table_entry->clientip);
-                break;
-            case COLUMN_CLIENTLEASETIME:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
+        case MODE_GET:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct dhcpclientTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_CLIENTINDEX:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->clientindex);
+                        break;
+                    case COLUMN_CLIENTMAC:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->clientmac,
+                                MACADDRSTRLEN);
+                        break;
+                    case COLUMN_CLIENTIP:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
+                                table_entry->clientip);
+                        break;
+                    case COLUMN_CLIENTLEASETIME:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
+                                table_entry->clientleasetime);
+                        break;
+                    default:
+                        netsnmp_set_request_error(reqinfo, request,
+                                SNMP_NOSUCHOBJECT);
+                        break;
                 }
-                snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
-                                            table_entry->clientleasetime);
-                break;
-            default:
-                netsnmp_set_request_error(reqinfo, request,
-                                          SNMP_NOSUCHOBJECT);
-                break;
             }
-        }
-        break;
+            break;
 
     }
     return SNMP_ERR_NOERROR;
 }
 
 /** Initialize the wifistationTable table by defining its contents and how it's structured */
-void
+    void
 initialize_table_wifistationTable(void)
 {
     const oid wifistationTable_oid[] = {1,3,6,1,4,1,46227,2,7,2};
@@ -6024,30 +6109,30 @@ initialize_table_wifistationTable(void)
     DEBUGMSGTL(("gxgdWiFiModule_table:init", "initializing table wifistationTable\n"));
 
     reg = netsnmp_create_handler_registration(
-              "wifistationTable",     wifistationTable_handler,
-              wifistationTable_oid, wifistationTable_oid_len,
-              HANDLER_CAN_RONLY
-              );
+            "wifistationTable",     wifistationTable_handler,
+            wifistationTable_oid, wifistationTable_oid_len,
+            HANDLER_CAN_RONLY
+            );
 
     table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
     netsnmp_table_helper_add_indexes(table_info,
-                           ASN_INTEGER,  /* index: stationindex */
-                           0);
+            ASN_INTEGER,  /* index: stationindex */
+            0);
     table_info->min_column = COLUMN_STATIONINDEX;
     table_info->max_column = COLUMN_ASSOCTIME;
-    
+
     iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
     iinfo->get_first_data_point = wifistationTable_get_first_data_point;
     iinfo->get_next_data_point  = wifistationTable_get_next_data_point;
     iinfo->table_reginfo        = table_info;
-    
+
     netsnmp_register_table_iterator( reg, iinfo );
 
     /* Initialise the contents of the table here */
     buildwifistationtable();
 }
 
-    /* Typical data structure for a row entry */
+/* Typical data structure for a row entry */
 struct wifistationTable_entry {
     /* Index values */
     long stationindex;
@@ -6088,8 +6173,8 @@ wifistationTable_removeEntry( struct wifistationTable_entry *entry ) {
         return;    /* Nothing to remove */
 
     for ( ptr  = wifistationTable_head, prev = NULL;
-          ptr != NULL;
-          prev = ptr, ptr = ptr->next ) {
+            ptr != NULL;
+            prev = ptr, ptr = ptr->next ) {
         if ( ptr == entry )
             break;
     }
@@ -6106,23 +6191,23 @@ wifistationTable_removeEntry( struct wifistationTable_entry *entry ) {
 
 
 /* Example iterator hook routines - using 'get_next' to do most of the work */
-netsnmp_variable_list *
+    netsnmp_variable_list *
 wifistationTable_get_first_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     buildwifistationtable();
     *my_loop_context = wifistationTable_head;
     return wifistationTable_get_next_data_point(my_loop_context, my_data_context,
-                                    put_index_data,  mydata );
+            put_index_data,  mydata );
 }
 
-netsnmp_variable_list *
+    netsnmp_variable_list *
 wifistationTable_get_next_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     struct wifistationTable_entry *entry = (struct wifistationTable_entry *)*my_loop_context;
     netsnmp_variable_list *idx = put_index_data;
@@ -6141,8 +6226,8 @@ wifistationTable_get_next_data_point(void **my_loop_context,
 void buildwifistationtable()
 {
     int mac_list_size, i;
-	char buf[sizeof(sta_info_t)];
-	char *ifname;
+    char buf[sizeof(sta_info_t)];
+    char *ifname;
     char ea_str[MACADDRSTRLEN];
     struct maclist *mac_list;
     struct wifistationTable_entry *entry;
@@ -6209,10 +6294,10 @@ void buildwifistationtable()
 /** handles requests for the wifistationTable table */
 int
 wifistationTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
+        netsnmp_mib_handler               *handler,
+        netsnmp_handler_registration      *reginfo,
+        netsnmp_agent_request_info        *reqinfo,
+        netsnmp_request_info              *requests) {
 
     netsnmp_request_info       *request;
     netsnmp_table_request_info *table_info;
@@ -6224,55 +6309,55 @@ wifistationTable_handler(
         /*
          * Read-support (also covers GetNext requests)
          */
-    case MODE_GET:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct wifistationTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_STATIONINDEX:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->stationindex);
-                break;
-            case COLUMN_STATIONMAC:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->stationmac,
-                                          MACADDRSTRLEN);
-                break;
-            case COLUMN_ASSOCTIME:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
+        case MODE_GET:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct wifistationTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_STATIONINDEX:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->stationindex);
+                        break;
+                    case COLUMN_STATIONMAC:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->stationmac,
+                                MACADDRSTRLEN);
+                        break;
+                    case COLUMN_ASSOCTIME:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
+                                table_entry->assoctime);
+                        break;
+                    default:
+                        netsnmp_set_request_error(reqinfo, request,
+                                SNMP_NOSUCHOBJECT);
+                        break;
                 }
-                snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
-                                            table_entry->assoctime);
-                break;
-            default:
-                netsnmp_set_request_error(reqinfo, request,
-                                          SNMP_NOSUCHOBJECT);
-                break;
             }
-        }
-        break;
+            break;
 
     }
     return SNMP_ERR_NOERROR;
 }
 
 /** Initialize the vlanTable table by defining its contents and how it's structured */
-void
+    void
 initialize_table_vlanTable(void)
 {
     const oid vlanTable_oid[] = {1,3,6,1,4,1,46227,2,3,1,1,46};
@@ -6284,30 +6369,30 @@ initialize_table_vlanTable(void)
     DEBUGMSGTL(("gxgdWiFiModule_table:init", "initializing table vlanTable\n"));
 
     reg = netsnmp_create_handler_registration(
-              "vlanTable",     vlanTable_handler,
-              vlanTable_oid, vlanTable_oid_len,
-              HANDLER_CAN_RONLY
-              );
+            "vlanTable",     vlanTable_handler,
+            vlanTable_oid, vlanTable_oid_len,
+            HANDLER_CAN_RONLY
+            );
 
     table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
     netsnmp_table_helper_add_indexes(table_info,
-                           ASN_INTEGER,  /* index: portnum */
-                           0);
+            ASN_INTEGER,  /* index: portnum */
+            0);
     table_info->min_column = COLUMN_PORT;
     table_info->max_column = COLUMN_PORTNUM;
-    
+
     iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
     iinfo->get_first_data_point = vlanTable_get_first_data_point;
     iinfo->get_next_data_point  = vlanTable_get_next_data_point;
     iinfo->table_reginfo        = table_info;
-    
+
     netsnmp_register_table_iterator( reg, iinfo );
 
     /* Initialise the contents of the table here */
     buildvlantable();
 }
 
-    /* Typical data structure for a row entry */
+/* Typical data structure for a row entry */
 struct vlanTable_entry {
     /* Column values */
     char portname[PORTNAMESIZE];
@@ -6359,8 +6444,8 @@ vlanTable_removeEntry( struct vlanTable_entry *entry ) {
         return;    /* Nothing to remove */
 
     for ( ptr  = vlanTable_head, prev = NULL;
-          ptr != NULL;
-          prev = ptr, ptr = ptr->next ) {
+            ptr != NULL;
+            prev = ptr, ptr = ptr->next ) {
         if ( ptr == entry )
             break;
     }
@@ -6377,23 +6462,23 @@ vlanTable_removeEntry( struct vlanTable_entry *entry ) {
 
 
 /* Example iterator hook routines - using 'get_next' to do most of the work */
-netsnmp_variable_list *
+    netsnmp_variable_list *
 vlanTable_get_first_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     buildvlantable();
     *my_loop_context = vlanTable_head;
     return vlanTable_get_next_data_point(my_loop_context, my_data_context,
-                                    put_index_data,  mydata );
+            put_index_data,  mydata );
 }
 
-netsnmp_variable_list *
+    netsnmp_variable_list *
 vlanTable_get_next_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     struct vlanTable_entry *entry = (struct vlanTable_entry *)*my_loop_context;
     netsnmp_variable_list *idx = put_index_data;
@@ -6413,10 +6498,10 @@ vlanTable_get_next_data_point(void **my_loop_context,
 /** handles requests for the vlanTable table */
 int
 vlanTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
+        netsnmp_mib_handler               *handler,
+        netsnmp_handler_registration      *reginfo,
+        netsnmp_agent_request_info        *reqinfo,
+        netsnmp_request_info              *requests) {
 
     netsnmp_request_info       *request;
     netsnmp_table_request_info *table_info;
@@ -6428,283 +6513,283 @@ vlanTable_handler(
         /*
          * Read-support (also covers GetNext requests)
          */
-    case MODE_GET:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vlanTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_PORT:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->portname,
-                                          table_entry->portname_len);
-                break;
-            case COLUMN_ENABLE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->enable);
-                break;
-            case COLUMN_MODE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->mode);
-                break;
-            case COLUMN_FWDMODE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->fwdmode);
-                break;
-            case COLUMN_VLANMODE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->vlanmode);
-                break;
-            case COLUMN_VID:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->vid);
-                break;
-            case COLUMN_PRIORITY:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->priority);
-                break;
-            case COLUMN_FRAMEENCAPMODE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->frameencapmode);
-                break;
-            case COLUMN_PORTNUM:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
+        case MODE_GET:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vlanTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_PORT:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->portname,
+                                table_entry->portname_len);
+                        break;
+                    case COLUMN_ENABLE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->enable);
+                        break;
+                    case COLUMN_MODE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->mode);
+                        break;
+                    case COLUMN_FWDMODE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->fwdmode);
+                        break;
+                    case COLUMN_VLANMODE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->vlanmode);
+                        break;
+                    case COLUMN_VID:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->vid);
+                        break;
+                    case COLUMN_PRIORITY:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->priority);
+                        break;
+                    case COLUMN_FRAMEENCAPMODE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->frameencapmode);
+                        break;
+                    case COLUMN_PORTNUM:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->portnum);
+                        break;
+                    default:
+                        netsnmp_set_request_error(reqinfo, request,
+                                SNMP_NOSUCHOBJECT);
+                        break;
                 }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->portnum);
-                break;
-            default:
-                netsnmp_set_request_error(reqinfo, request,
-                                          SNMP_NOSUCHOBJECT);
-                break;
             }
-        }
-        break;
+            break;
 
 #if 0
-        /*
-         * Write-support
-         */
-    case MODE_SET_RESERVE1:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vlanTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_MODE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_FWDMODE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_VLANMODE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_VID:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_PRIORITY:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_FRAMEENCAPMODE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_PORTNUM:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
+            /*
+             * Write-support
+             */
+        case MODE_SET_RESERVE1:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vlanTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_MODE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_FWDMODE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_VLANMODE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_VID:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_PRIORITY:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_FRAMEENCAPMODE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_PORTNUM:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    default:
+                        netsnmp_set_request_error( reqinfo, request,
+                                SNMP_ERR_NOTWRITABLE );
+                        return SNMP_ERR_NOERROR;
                 }
-                break;
-            default:
-                netsnmp_set_request_error( reqinfo, request,
-                                           SNMP_ERR_NOTWRITABLE );
-                return SNMP_ERR_NOERROR;
             }
-        }
-        break;
-
-    case MODE_SET_RESERVE2:
-        break;
-
-    case MODE_SET_FREE:
-        break;
-
-    case MODE_SET_ACTION:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vlanTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                table_entry->old_enable = table_entry->enable;
-                table_entry->enable     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_MODE:
-                table_entry->old_mode = table_entry->mode;
-                table_entry->mode     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_FWDMODE:
-                table_entry->old_fwdmode = table_entry->fwdmode;
-                table_entry->fwdmode     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_VLANMODE:
-                table_entry->old_vlanmode = table_entry->vlanmode;
-                table_entry->vlanmode     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_VID:
-                table_entry->old_vid = table_entry->vid;
-                table_entry->vid     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_PRIORITY:
-                table_entry->old_priority = table_entry->priority;
-                table_entry->priority     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_FRAMEENCAPMODE:
-                table_entry->old_frameencapmode = table_entry->frameencapmode;
-                table_entry->frameencapmode     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_PORTNUM:
-                table_entry->old_portnum = table_entry->portnum;
-                table_entry->portnum     = *request->requestvb->val.integer;
-                break;
+            break;
+
+        case MODE_SET_RESERVE2:
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vlanTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        table_entry->old_enable = table_entry->enable;
+                        table_entry->enable     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_MODE:
+                        table_entry->old_mode = table_entry->mode;
+                        table_entry->mode     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_FWDMODE:
+                        table_entry->old_fwdmode = table_entry->fwdmode;
+                        table_entry->fwdmode     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_VLANMODE:
+                        table_entry->old_vlanmode = table_entry->vlanmode;
+                        table_entry->vlanmode     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_VID:
+                        table_entry->old_vid = table_entry->vid;
+                        table_entry->vid     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_PRIORITY:
+                        table_entry->old_priority = table_entry->priority;
+                        table_entry->priority     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_FRAMEENCAPMODE:
+                        table_entry->old_frameencapmode = table_entry->frameencapmode;
+                        table_entry->frameencapmode     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_PORTNUM:
+                        table_entry->old_portnum = table_entry->portnum;
+                        table_entry->portnum     = *request->requestvb->val.integer;
+                        break;
+                }
             }
-        }
-        break;
-
-    case MODE_SET_UNDO:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vlanTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                table_entry->enable     = table_entry->old_enable;
-                table_entry->old_enable = 0;
-                break;
-            case COLUMN_MODE:
-                table_entry->mode     = table_entry->old_mode;
-                table_entry->old_mode = 0;
-                break;
-            case COLUMN_FWDMODE:
-                table_entry->fwdmode     = table_entry->old_fwdmode;
-                table_entry->old_fwdmode = 0;
-                break;
-            case COLUMN_VLANMODE:
-                table_entry->vlanmode     = table_entry->old_vlanmode;
-                table_entry->old_vlanmode = 0;
-                break;
-            case COLUMN_VID:
-                table_entry->vid     = table_entry->old_vid;
-                table_entry->old_vid = 0;
-                break;
-            case COLUMN_PRIORITY:
-                table_entry->priority     = table_entry->old_priority;
-                table_entry->old_priority = 0;
-                break;
-            case COLUMN_FRAMEENCAPMODE:
-                table_entry->frameencapmode     = table_entry->old_frameencapmode;
-                table_entry->old_frameencapmode = 0;
-                break;
-            case COLUMN_PORTNUM:
-                table_entry->portnum     = table_entry->old_portnum;
-                table_entry->old_portnum = 0;
-                break;
+            break;
+
+        case MODE_SET_UNDO:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vlanTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        table_entry->enable     = table_entry->old_enable;
+                        table_entry->old_enable = 0;
+                        break;
+                    case COLUMN_MODE:
+                        table_entry->mode     = table_entry->old_mode;
+                        table_entry->old_mode = 0;
+                        break;
+                    case COLUMN_FWDMODE:
+                        table_entry->fwdmode     = table_entry->old_fwdmode;
+                        table_entry->old_fwdmode = 0;
+                        break;
+                    case COLUMN_VLANMODE:
+                        table_entry->vlanmode     = table_entry->old_vlanmode;
+                        table_entry->old_vlanmode = 0;
+                        break;
+                    case COLUMN_VID:
+                        table_entry->vid     = table_entry->old_vid;
+                        table_entry->old_vid = 0;
+                        break;
+                    case COLUMN_PRIORITY:
+                        table_entry->priority     = table_entry->old_priority;
+                        table_entry->old_priority = 0;
+                        break;
+                    case COLUMN_FRAMEENCAPMODE:
+                        table_entry->frameencapmode     = table_entry->old_frameencapmode;
+                        table_entry->old_frameencapmode = 0;
+                        break;
+                    case COLUMN_PORTNUM:
+                        table_entry->portnum     = table_entry->old_portnum;
+                        table_entry->old_portnum = 0;
+                        break;
+                }
             }
-        }
-        break;
+            break;
 
-    case MODE_SET_COMMIT:
-        break;
+        case MODE_SET_COMMIT:
+            break;
 #endif
-    default:
-        break;
+        default:
+            break;
     }
     return SNMP_ERR_NOERROR;
 }
@@ -6776,7 +6861,7 @@ void buildvlantable()
 }
 
 /** Initialize the vidTable table by defining its contents and how it's structured */
-void
+    void
 initialize_table_vidTable(void)
 {
     const oid vidTable_oid[] = {1,3,6,1,4,1,46227,2,3,1,1,47};
@@ -6788,30 +6873,30 @@ initialize_table_vidTable(void)
     DEBUGMSGTL(("gxgdWiFiModule_table:init", "initializing table vidTable\n"));
 
     reg = netsnmp_create_handler_registration(
-              "vidTable",     vidTable_handler,
-              vidTable_oid, vidTable_oid_len,
-              HANDLER_CAN_RONLY
-              );
+            "vidTable",     vidTable_handler,
+            vidTable_oid, vidTable_oid_len,
+            HANDLER_CAN_RONLY
+            );
 
     table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
     netsnmp_table_helper_add_indexes(table_info,
-                           ASN_INTEGER,  /* index: portnum */
-                           0);
+            ASN_INTEGER,  /* index: portnum */
+            0);
     table_info->min_column = COLUMN_PORT;
     table_info->max_column = COLUMN_PORTNUM;
-    
+
     iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
     iinfo->get_first_data_point = vidTable_get_first_data_point;
     iinfo->get_next_data_point  = vidTable_get_next_data_point;
     iinfo->table_reginfo        = table_info;
-    
+
     netsnmp_register_table_iterator( reg, iinfo );
 
     /* Initialise the contents of the table here */
     buildvidtable();
 }
 
-    /* Typical data structure for a row entry */
+/* Typical data structure for a row entry */
 struct vidTable_entry {
     /* Column values */
     char portname[PORTNAMESIZE];
@@ -6855,8 +6940,8 @@ vidTable_removeEntry( struct vidTable_entry *entry ) {
         return;    /* Nothing to remove */
 
     for ( ptr  = vidTable_head, prev = NULL;
-          ptr != NULL;
-          prev = ptr, ptr = ptr->next ) {
+            ptr != NULL;
+            prev = ptr, ptr = ptr->next ) {
         if ( ptr == entry )
             break;
     }
@@ -6873,23 +6958,23 @@ vidTable_removeEntry( struct vidTable_entry *entry ) {
 
 
 /* Example iterator hook routines - using 'get_next' to do most of the work */
-netsnmp_variable_list *
+    netsnmp_variable_list *
 vidTable_get_first_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     buildvidtable();
     *my_loop_context = vidTable_head;
     return vidTable_get_next_data_point(my_loop_context, my_data_context,
-                                    put_index_data,  mydata );
+            put_index_data,  mydata );
 }
 
-netsnmp_variable_list *
+    netsnmp_variable_list *
 vidTable_get_next_data_point(void **my_loop_context,
-                          void **my_data_context,
-                          netsnmp_variable_list *put_index_data,
-                          netsnmp_iterator_info *mydata)
+        void **my_data_context,
+        netsnmp_variable_list *put_index_data,
+        netsnmp_iterator_info *mydata)
 {
     struct vidTable_entry *entry = (struct vidTable_entry *)*my_loop_context;
     netsnmp_variable_list *idx = put_index_data;
@@ -6909,10 +6994,10 @@ vidTable_get_next_data_point(void **my_loop_context,
 /** handles requests for the vidTable table */
 int
 vidTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
+        netsnmp_mib_handler               *handler,
+        netsnmp_handler_registration      *reginfo,
+        netsnmp_agent_request_info        *reqinfo,
+        netsnmp_request_info              *requests) {
 
     netsnmp_request_info       *request;
     netsnmp_table_request_info *table_info;
@@ -6924,183 +7009,183 @@ vidTable_handler(
         /*
          * Read-support (also covers GetNext requests)
          */
-    case MODE_GET:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vidTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_PORT:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
-                                          table_entry->portname,
-                                          table_entry->portname_len);
-                break;
-            case COLUMN_ENABLE:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->enable);
-                break;
-            case COLUMN_NATVID:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->natvid);
-                break;
-            case COLUMN_BRIDGEVID:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
-                }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->bridgevid);
-                break;
-            case COLUMN_PORTNUM:
-                if ( !table_entry ) {
-                    netsnmp_set_request_error(reqinfo, request,
-                                              SNMP_NOSUCHINSTANCE);
-                    continue;
+        case MODE_GET:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vidTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_PORT:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                table_entry->portname,
+                                table_entry->portname_len);
+                        break;
+                    case COLUMN_ENABLE:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->enable);
+                        break;
+                    case COLUMN_NATVID:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->natvid);
+                        break;
+                    case COLUMN_BRIDGEVID:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->bridgevid);
+                        break;
+                    case COLUMN_PORTNUM:
+                        if ( !table_entry ) {
+                            netsnmp_set_request_error(reqinfo, request,
+                                    SNMP_NOSUCHINSTANCE);
+                            continue;
+                        }
+                        snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                table_entry->portnum);
+                        break;
+                    default:
+                        netsnmp_set_request_error(reqinfo, request,
+                                SNMP_NOSUCHOBJECT);
+                        break;
                 }
-                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
-                                            table_entry->portnum);
-                break;
-            default:
-                netsnmp_set_request_error(reqinfo, request,
-                                          SNMP_NOSUCHOBJECT);
-                break;
             }
-        }
-        break;
+            break;
 
 #if 0
-        /*
-         * Write-support
-         */
-    case MODE_SET_RESERVE1:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vidTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_NATVID:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_BRIDGEVID:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
-                }
-                break;
-            case COLUMN_PORTNUM:
-                /* or possibly 'netsnmp_check_vb_int_range' */
-                ret = netsnmp_check_vb_int( request->requestvb );
-                if ( ret != SNMP_ERR_NOERROR ) {
-                    netsnmp_set_request_error( reqinfo, request, ret );
-                    return SNMP_ERR_NOERROR;
+            /*
+             * Write-support
+             */
+        case MODE_SET_RESERVE1:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vidTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_NATVID:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_BRIDGEVID:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    case COLUMN_PORTNUM:
+                        /* or possibly 'netsnmp_check_vb_int_range' */
+                        ret = netsnmp_check_vb_int( request->requestvb );
+                        if ( ret != SNMP_ERR_NOERROR ) {
+                            netsnmp_set_request_error( reqinfo, request, ret );
+                            return SNMP_ERR_NOERROR;
+                        }
+                        break;
+                    default:
+                        netsnmp_set_request_error( reqinfo, request,
+                                SNMP_ERR_NOTWRITABLE );
+                        return SNMP_ERR_NOERROR;
                 }
-                break;
-            default:
-                netsnmp_set_request_error( reqinfo, request,
-                                           SNMP_ERR_NOTWRITABLE );
-                return SNMP_ERR_NOERROR;
             }
-        }
-        break;
-
-    case MODE_SET_RESERVE2:
-        break;
-
-    case MODE_SET_FREE:
-        break;
-
-    case MODE_SET_ACTION:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vidTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                table_entry->old_enable = table_entry->enable;
-                table_entry->enable     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_NATVID:
-                table_entry->old_natvid = table_entry->natvid;
-                table_entry->natvid     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_BRIDGEVID:
-                table_entry->old_bridgevid = table_entry->bridgevid;
-                table_entry->bridgevid     = *request->requestvb->val.integer;
-                break;
-            case COLUMN_PORTNUM:
-                table_entry->old_portnum = table_entry->portnum;
-                table_entry->portnum     = *request->requestvb->val.integer;
-                break;
+            break;
+
+        case MODE_SET_RESERVE2:
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        case MODE_SET_ACTION:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vidTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        table_entry->old_enable = table_entry->enable;
+                        table_entry->enable     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_NATVID:
+                        table_entry->old_natvid = table_entry->natvid;
+                        table_entry->natvid     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_BRIDGEVID:
+                        table_entry->old_bridgevid = table_entry->bridgevid;
+                        table_entry->bridgevid     = *request->requestvb->val.integer;
+                        break;
+                    case COLUMN_PORTNUM:
+                        table_entry->old_portnum = table_entry->portnum;
+                        table_entry->portnum     = *request->requestvb->val.integer;
+                        break;
+                }
             }
-        }
-        break;
-
-    case MODE_SET_UNDO:
-        for (request=requests; request; request=request->next) {
-            table_entry = (struct vidTable_entry *)
-                              netsnmp_extract_iterator_context(request);
-            table_info  =     netsnmp_extract_table_info(      request);
-    
-            switch (table_info->colnum) {
-            case COLUMN_ENABLE:
-                table_entry->enable     = table_entry->old_enable;
-                table_entry->old_enable = 0;
-                break;
-            case COLUMN_NATVID:
-                table_entry->natvid     = table_entry->old_natvid;
-                table_entry->old_natvid = 0;
-                break;
-            case COLUMN_BRIDGEVID:
-                table_entry->bridgevid     = table_entry->old_bridgevid;
-                table_entry->old_bridgevid = 0;
-                break;
-            case COLUMN_PORTNUM:
-                table_entry->portnum     = table_entry->old_portnum;
-                table_entry->old_portnum = 0;
-                break;
+            break;
+
+        case MODE_SET_UNDO:
+            for (request=requests; request; request=request->next) {
+                table_entry = (struct vidTable_entry *)
+                    netsnmp_extract_iterator_context(request);
+                table_info  =     netsnmp_extract_table_info(      request);
+
+                switch (table_info->colnum) {
+                    case COLUMN_ENABLE:
+                        table_entry->enable     = table_entry->old_enable;
+                        table_entry->old_enable = 0;
+                        break;
+                    case COLUMN_NATVID:
+                        table_entry->natvid     = table_entry->old_natvid;
+                        table_entry->old_natvid = 0;
+                        break;
+                    case COLUMN_BRIDGEVID:
+                        table_entry->bridgevid     = table_entry->old_bridgevid;
+                        table_entry->old_bridgevid = 0;
+                        break;
+                    case COLUMN_PORTNUM:
+                        table_entry->portnum     = table_entry->old_portnum;
+                        table_entry->old_portnum = 0;
+                        break;
+                }
             }
-        }
-        break;
+            break;
 
-    case MODE_SET_COMMIT:
-        break;
+        case MODE_SET_COMMIT:
+            break;
 #endif
-    default:
-        break;
+        default:
+            break;
     }
     return SNMP_ERR_NOERROR;
 }
diff --git a/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.h b/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.h
index 9058f61..b4be921 100644
--- a/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.h
+++ b/src/router/net-snmp/agent/mibgroup/gxgdWiFiModule.h
@@ -21,6 +21,7 @@ Netsnmp_Node_Handler handle_pppoestart;
 Netsnmp_Node_Handler handle_pppoeconnectionstatus;
 Netsnmp_Node_Handler handle_pppoeon;
 Netsnmp_Node_Handler handle_wanon;
+Netsnmp_Node_Handler handle_wandhcpoption60;
 Netsnmp_Node_Handler handle_wirelessmode;
 Netsnmp_Node_Handler handle_pppoeconnectondemand;
 Netsnmp_Node_Handler handle_pppoedisconnect;
diff --git a/src/router/shared/defaults.c b/src/router/shared/defaults.c
index fb47182..3bd2485 100644
--- a/src/router/shared/defaults.c
+++ b/src/router/shared/defaults.c
@@ -161,6 +161,10 @@ struct nvram_tuple router_defaults[] = {
 
 	{ "wan_unit", "0", 0 },			/* Last configured connection */
 
+#ifdef LW_CUST
+	{ "wan_dhcpoption60", "gxcatv.nat.v2.0.0", 0 },	/* wan dhcp60 options */
+#endif
+
 	/* Filters */
 	{ "filter_maclist", "", 0 },		/* xx:xx:xx:xx:xx:xx ... */
 	{ "filter_macmode", "deny", 0 },	/* "allow" only, "deny" only, or "disabled"
diff --git a/src/router/udhcpd/Makefile b/src/router/udhcpd/Makefile
index 5cdd5ed..8177f03 100644
--- a/src/router/udhcpd/Makefile
+++ b/src/router/udhcpd/Makefile
@@ -51,7 +51,9 @@ ifdef SYSLOG
 CFLAGS += -DSYSLOG
 endif
 
-CFLAGS += -W -Wall -Wstrict-prototypes -DVERSION='"$(VER)"'
+CFLAGS += -W -Wall -Wstrict-prototypes -DVERSION='"$(VER)"' -I$(SRCBASE)/include -I$(TOP)/shared
+
+LDFLAGS += -L$(TOP)/nvram -lnvram
 
 ifdef DEBUG
 CFLAGS += -g -DDEBUG
diff --git a/src/router/udhcpd/clientpacket.c b/src/router/udhcpd/clientpacket.c
index 513c68a..c1d6d94 100644
--- a/src/router/udhcpd/clientpacket.c
+++ b/src/router/udhcpd/clientpacket.c
@@ -47,6 +47,7 @@
 #include "dhcpc.h"
 #include "debug.h"
 
+#include <bcmnvram.h>
 
 /* Create a random xid */
 unsigned long random_xid(void)
@@ -71,23 +72,29 @@ unsigned long random_xid(void)
 
 
 /* initialize a packet with the proper defaults */
+#define MAX_DHCP_OPTION60_LEN 32
+
 static void init_packet(struct dhcpMessage *packet, char type)
 {
-#ifdef LW_CUST
+    char *poption60;
+    int option60len;
+
 	struct vendor  {
 		char vendor, length;
-		char str[sizeof("gxcatv.nat.v2.0.0")];
+		char str[MAX_DHCP_OPTION60_LEN];
 	} vendor_id = { DHCP_VENDOR,  sizeof("gxcatv.nat.v2.0.0") - 1, "gxcatv.nat.v2.0.0"};
-#else
-	struct vendor  {
-		char vendor, length;
-		char str[sizeof("udhcp "VERSION)];
-	} vendor_id = { DHCP_VENDOR,  sizeof("udhcp "VERSION) - 1, "udhcp "VERSION};
-#endif
+
 	init_header(packet, type);
 	memcpy(packet->chaddr, client_config.arp, 6);
 	add_option_string(packet->options, client_config.clientid);
 	if (client_config.hostname) add_option_string(packet->options, client_config.hostname);
+
+    poption60 = nvram_safe_get("wan_dhcpoption60");
+    option60len = strlen(poption60);
+    if(option60len > 0 && option60len < MAX_DHCP_OPTION60_LEN){
+        vendor_id.length = option60len;
+        strcpy(vendor_id.str, poption60);
+    }
 	add_option_string(packet->options, (unsigned char *) &vendor_id);
 }
 
